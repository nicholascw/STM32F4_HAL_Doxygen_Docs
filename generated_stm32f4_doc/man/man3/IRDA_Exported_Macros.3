.TH "IRDA_Exported_Macros" 3 "2020年 八月 7日 星期五" "Version 1.24.0" "STM32F4_HAL" \" -*- nroff -*-
.ad l
.nh
.SH NAME
IRDA_Exported_Macros
.SH SYNOPSIS
.br
.PP
.SS "宏定义"

.in +1c
.ti -1c
.RI "#define \fB__HAL_IRDA_RESET_HANDLE_STATE\fP(__HANDLE__)"
.br
.RI "Reset IRDA handle gstate & RxState "
.ti -1c
.RI "#define \fB__HAL_IRDA_FLUSH_DRREGISTER\fP(__HANDLE__)   ((__HANDLE__)\->Instance\->DR)"
.br
.RI "Flush the IRDA DR register "
.ti -1c
.RI "#define \fB__HAL_IRDA_GET_FLAG\fP(__HANDLE__,  __FLAG__)   (((__HANDLE__)\->Instance\->SR & (__FLAG__)) == (__FLAG__))"
.br
.RI "Check whether the specified IRDA flag is set or not\&. "
.ti -1c
.RI "#define \fB__HAL_IRDA_CLEAR_FLAG\fP(__HANDLE__,  __FLAG__)   ((__HANDLE__)\->Instance\->SR = ~(__FLAG__))"
.br
.RI "Clear the specified IRDA pending flag\&. "
.ti -1c
.RI "#define \fB__HAL_IRDA_CLEAR_PEFLAG\fP(__HANDLE__)"
.br
.RI "Clear the IRDA PE pending flag\&. "
.ti -1c
.RI "#define \fB__HAL_IRDA_CLEAR_FEFLAG\fP(__HANDLE__)   \fB__HAL_IRDA_CLEAR_PEFLAG\fP(__HANDLE__)"
.br
.RI "Clear the IRDA FE pending flag\&. "
.ti -1c
.RI "#define \fB__HAL_IRDA_CLEAR_NEFLAG\fP(__HANDLE__)   \fB__HAL_IRDA_CLEAR_PEFLAG\fP(__HANDLE__)"
.br
.RI "Clear the IRDA NE pending flag\&. "
.ti -1c
.RI "#define \fB__HAL_IRDA_CLEAR_OREFLAG\fP(__HANDLE__)   \fB__HAL_IRDA_CLEAR_PEFLAG\fP(__HANDLE__)"
.br
.RI "Clear the IRDA ORE pending flag\&. "
.ti -1c
.RI "#define \fB__HAL_IRDA_CLEAR_IDLEFLAG\fP(__HANDLE__)   \fB__HAL_IRDA_CLEAR_PEFLAG\fP(__HANDLE__)"
.br
.RI "Clear the IRDA IDLE pending flag\&. "
.ti -1c
.RI "#define \fB__HAL_IRDA_ENABLE_IT\fP(__HANDLE__,  __INTERRUPT__)"
.br
.RI "Enable the specified IRDA interrupt\&. "
.ti -1c
.RI "#define \fB__HAL_IRDA_DISABLE_IT\fP(__HANDLE__,  __INTERRUPT__)"
.br
.RI "Disable the specified IRDA interrupt\&. "
.ti -1c
.RI "#define \fB__HAL_IRDA_GET_IT_SOURCE\fP(__HANDLE__,  __IT__)"
.br
.RI "Check whether the specified IRDA interrupt has occurred or not\&. "
.ti -1c
.RI "#define \fB__HAL_IRDA_ONE_BIT_SAMPLE_ENABLE\fP(__HANDLE__)   ((__HANDLE__)\->Instance\->CR3 |= USART_CR3_ONEBIT)"
.br
.RI "Macro to enable the IRDA's one bit sample method "
.ti -1c
.RI "#define \fB__HAL_IRDA_ONE_BIT_SAMPLE_DISABLE\fP(__HANDLE__)   ((__HANDLE__)\->Instance\->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT))"
.br
.RI "Macro to disable the IRDA's one bit sample method "
.ti -1c
.RI "#define \fB__HAL_IRDA_ENABLE\fP(__HANDLE__)   (SET_BIT((__HANDLE__)\->Instance\->CR1, USART_CR1_UE))"
.br
.RI "Enable UART/USART associated to IRDA Handle "
.ti -1c
.RI "#define \fB__HAL_IRDA_DISABLE\fP(__HANDLE__)   (CLEAR_BIT((__HANDLE__)\->Instance\->CR1, USART_CR1_UE))"
.br
.RI "Disable UART/USART associated to IRDA Handle "
.in -1c
.SH "详细描述"
.PP 

.SH "宏定义说明"
.PP 
.SS "#define __HAL_IRDA_CLEAR_FEFLAG(__HANDLE__)   \fB__HAL_IRDA_CLEAR_PEFLAG\fP(__HANDLE__)"

.PP
Clear the IRDA FE pending flag\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the IRDA Handle\&. IRDA Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_irda\&.h 第 426 行定义\&.
.SS "#define __HAL_IRDA_CLEAR_FLAG(__HANDLE__, __FLAG__)   ((__HANDLE__)\->Instance\->SR = ~(__FLAG__))"

.PP
Clear the specified IRDA pending flag\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the IRDA Handle\&. IRDA Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.br
\fI<strong>FLAG</strong>\fP specifies the flag to check\&. This parameter can be any combination of the following values: 
.PD 0

.IP "\(bu" 2
IRDA_FLAG_TC: Transmission Complete flag\&. 
.IP "\(bu" 2
IRDA_FLAG_RXNE: Receive data register not empty flag\&.
.PP
.RE
.PP
\fB注解\fP
.RS 4
PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun error) and IDLE (Idle line detected) flags are cleared by software sequence: a read operation to USART_SR register followed by a read operation to USART_DR register\&. 
.PP
RXNE flag can be also cleared by a read to the USART_DR register\&. 
.PP
TC flag can be also cleared by software sequence: a read operation to USART_SR register followed by a write operation to USART_DR register\&. 
.PP
TXE flag is cleared only by a write to the USART_DR register\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_irda\&.h 第 404 行定义\&.
.SS "#define __HAL_IRDA_CLEAR_IDLEFLAG(__HANDLE__)   \fB__HAL_IRDA_CLEAR_PEFLAG\fP(__HANDLE__)"

.PP
Clear the IRDA IDLE pending flag\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the IRDA Handle\&. IRDA Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_irda\&.h 第 450 行定义\&.
.SS "#define __HAL_IRDA_CLEAR_NEFLAG(__HANDLE__)   \fB__HAL_IRDA_CLEAR_PEFLAG\fP(__HANDLE__)"

.PP
Clear the IRDA NE pending flag\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the IRDA Handle\&. IRDA Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_irda\&.h 第 434 行定义\&.
.SS "#define __HAL_IRDA_CLEAR_OREFLAG(__HANDLE__)   \fB__HAL_IRDA_CLEAR_PEFLAG\fP(__HANDLE__)"

.PP
Clear the IRDA ORE pending flag\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the IRDA Handle\&. IRDA Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_irda\&.h 第 442 行定义\&.
.SS "#define __HAL_IRDA_CLEAR_PEFLAG(__HANDLE__)"
\fB值:\fP
.PP
.nf
  do{                                           \
    __IO uint32_t tmpreg = 0x00U;               \
    tmpreg = (__HANDLE__)->Instance->SR;        \
    tmpreg = (__HANDLE__)->Instance->DR;        \
    UNUSED(tmpreg);                             \
  } while(0U)
.fi
.PP
Clear the IRDA PE pending flag\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the IRDA Handle\&. IRDA Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_irda\&.h 第 412 行定义\&.
.SS "#define __HAL_IRDA_DISABLE(__HANDLE__)   (CLEAR_BIT((__HANDLE__)\->Instance\->CR1, USART_CR1_UE))"

.PP
Disable UART/USART associated to IRDA Handle 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the IRDA Handle\&. IRDA Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_irda\&.h 第 530 行定义\&.
.SS "#define __HAL_IRDA_DISABLE_IT(__HANDLE__, __INTERRUPT__)"
\fB值:\fP
.PP
.nf
                                                           ((((__INTERRUPT__) >> 28U) == IRDA_CR1_REG_INDEX)? ((__HANDLE__)->Instance->CR1 &= ~((__INTERRUPT__) & IRDA_IT_MASK)): \
                                                           (((__INTERRUPT__) >> 28U) == IRDA_CR2_REG_INDEX)? ((__HANDLE__)->Instance->CR2 &= ~((__INTERRUPT__) & IRDA_IT_MASK)): \
                                                           ((__HANDLE__)->Instance->CR3 &= ~ ((__INTERRUPT__) & IRDA_IT_MASK)))
.fi
.PP
Disable the specified IRDA interrupt\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the IRDA Handle\&. IRDA Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.br
\fI<strong>INTERRUPT</strong>\fP specifies the IRDA interrupt source to disable\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
IRDA_IT_TXE: Transmit Data Register empty interrupt 
.IP "\(bu" 2
IRDA_IT_TC: Transmission complete interrupt 
.IP "\(bu" 2
IRDA_IT_RXNE: Receive Data register not empty interrupt 
.IP "\(bu" 2
IRDA_IT_IDLE: Idle line detection interrupt 
.IP "\(bu" 2
IRDA_IT_PE: Parity Error interrupt 
.IP "\(bu" 2
IRDA_IT_ERR: Error interrupt(Frame error, noise error, overrun error) 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_irda\&.h 第 483 行定义\&.
.SS "#define __HAL_IRDA_ENABLE(__HANDLE__)   (SET_BIT((__HANDLE__)\->Instance\->CR1, USART_CR1_UE))"

.PP
Enable UART/USART associated to IRDA Handle 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the IRDA Handle\&. IRDA Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_irda\&.h 第 522 行定义\&.
.SS "#define __HAL_IRDA_ENABLE_IT(__HANDLE__, __INTERRUPT__)"
\fB值:\fP
.PP
.nf
                                                           ((((__INTERRUPT__) >> 28U) == IRDA_CR1_REG_INDEX)? ((__HANDLE__)->Instance->CR1 |= ((__INTERRUPT__) & IRDA_IT_MASK)): \
                                                           (((__INTERRUPT__) >> 28U) == IRDA_CR2_REG_INDEX)? ((__HANDLE__)->Instance->CR2 |=  ((__INTERRUPT__) & IRDA_IT_MASK)): \
                                                            ((__HANDLE__)->Instance->CR3 |= ((__INTERRUPT__) & IRDA_IT_MASK)))
.fi
.PP
Enable the specified IRDA interrupt\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the IRDA Handle\&. IRDA Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.br
\fI<strong>INTERRUPT</strong>\fP specifies the IRDA interrupt source to enable\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
IRDA_IT_TXE: Transmit Data Register empty interrupt 
.IP "\(bu" 2
IRDA_IT_TC: Transmission complete interrupt 
.IP "\(bu" 2
IRDA_IT_RXNE: Receive Data register not empty interrupt 
.IP "\(bu" 2
IRDA_IT_IDLE: Idle line detection interrupt 
.IP "\(bu" 2
IRDA_IT_PE: Parity Error interrupt 
.IP "\(bu" 2
IRDA_IT_ERR: Error interrupt(Frame error, noise error, overrun error) 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_irda\&.h 第 466 行定义\&.
.SS "#define __HAL_IRDA_FLUSH_DRREGISTER(__HANDLE__)   ((__HANDLE__)\->Instance\->DR)"

.PP
Flush the IRDA DR register 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the IRDA Handle\&. IRDA Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_irda\&.h 第 365 行定义\&.
.SS "#define __HAL_IRDA_GET_FLAG(__HANDLE__, __FLAG__)   (((__HANDLE__)\->Instance\->SR & (__FLAG__)) == (__FLAG__))"

.PP
Check whether the specified IRDA flag is set or not\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the IRDA Handle\&. IRDA Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.br
\fI<strong>FLAG</strong>\fP specifies the flag to check\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
IRDA_FLAG_TXE: Transmit data register empty flag 
.IP "\(bu" 2
IRDA_FLAG_TC: Transmission Complete flag 
.IP "\(bu" 2
IRDA_FLAG_RXNE: Receive data register not empty flag 
.IP "\(bu" 2
IRDA_FLAG_IDLE: Idle Line detection flag 
.IP "\(bu" 2
IRDA_FLAG_ORE: OverRun Error flag 
.IP "\(bu" 2
IRDA_FLAG_NE: Noise Error flag 
.IP "\(bu" 2
IRDA_FLAG_FE: Framing Error flag 
.IP "\(bu" 2
IRDA_FLAG_PE: Parity Error flag 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fIThe\fP new state of \fBFLAG\fP (TRUE or FALSE)\&. 
.RE
.PP

.PP
在文件 stm32f4xx_hal_irda\&.h 第 383 行定义\&.
.SS "#define __HAL_IRDA_GET_IT_SOURCE(__HANDLE__, __IT__)"
\fB值:\fP
.PP
.nf
                                                      (((((__IT__) >> 28U) == IRDA_CR1_REG_INDEX)? (__HANDLE__)->Instance->CR1:(((((uint32_t)(__IT__)) >> 28U) == IRDA_CR2_REG_INDEX)? \
                                                      (__HANDLE__)->Instance->CR2 : (__HANDLE__)->Instance->CR3)) & (((uint32_t)(__IT__)) & IRDA_IT_MASK))
.fi
.PP
Check whether the specified IRDA interrupt has occurred or not\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the IRDA Handle\&. IRDA Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.br
\fI<strong>IT</strong>\fP specifies the IRDA interrupt source to check\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
IRDA_IT_TXE: Transmit Data Register empty interrupt 
.IP "\(bu" 2
IRDA_IT_TC: Transmission complete interrupt 
.IP "\(bu" 2
IRDA_IT_RXNE: Receive Data register not empty interrupt 
.IP "\(bu" 2
IRDA_IT_IDLE: Idle line detection interrupt 
.IP "\(bu" 2
IRDA_IT_ERR: Error interrupt 
.IP "\(bu" 2
IRDA_IT_PE: Parity Error interrupt 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fIThe\fP new state of \fBIT\fP (TRUE or FALSE)\&. 
.RE
.PP

.PP
在文件 stm32f4xx_hal_irda\&.h 第 501 行定义\&.
.SS "#define __HAL_IRDA_ONE_BIT_SAMPLE_DISABLE(__HANDLE__)   ((__HANDLE__)\->Instance\->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT))"

.PP
Macro to disable the IRDA's one bit sample method 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the IRDA Handle\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_irda\&.h 第 514 行定义\&.
.SS "#define __HAL_IRDA_ONE_BIT_SAMPLE_ENABLE(__HANDLE__)   ((__HANDLE__)\->Instance\->CR3 |= USART_CR3_ONEBIT)"

.PP
Macro to enable the IRDA's one bit sample method 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the IRDA Handle\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_irda\&.h 第 508 行定义\&.
.SS "#define __HAL_IRDA_RESET_HANDLE_STATE(__HANDLE__)"
\fB值:\fP
.PP
.nf
                                                       do{                                                   \
                                                       (__HANDLE__)->gState = HAL_IRDA_STATE_RESET;      \
                                                       (__HANDLE__)->RxState = HAL_IRDA_STATE_RESET;     \
                                                     } while(0U)
.fi
.PP
Reset IRDA handle gstate & RxState 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the IRDA Handle\&. IRDA Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_irda\&.h 第 353 行定义\&.
.SH "作者"
.PP 
由 Doyxgen 通过分析 STM32F4_HAL 的 源代码自动生成\&.
