.TH "SMBUS_Exported_Macros" 3 "2020年 八月 7日 星期五" "Version 1.24.0" "STM32F4_HAL" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SMBUS_Exported_Macros
.SH SYNOPSIS
.br
.PP
.SS "宏定义"

.in +1c
.ti -1c
.RI "#define \fB__HAL_SMBUS_RESET_HANDLE_STATE\fP(__HANDLE__)   ((__HANDLE__)\->State = \fBHAL_SMBUS_STATE_RESET\fP)"
.br
.RI "Reset SMBUS handle state "
.ti -1c
.RI "#define \fB__HAL_SMBUS_ENABLE_IT\fP(__HANDLE__,  __INTERRUPT__)   ((__HANDLE__)\->Instance\->CR2 |= (__INTERRUPT__))"
.br
.RI "Enable or disable the specified SMBUS interrupts\&. "
.ti -1c
.RI "#define \fB__HAL_SMBUS_DISABLE_IT\fP(__HANDLE__,  __INTERRUPT__)   ((__HANDLE__)\->Instance\->CR2 &= (~(__INTERRUPT__)))"
.br
.ti -1c
.RI "#define \fB__HAL_SMBUS_GET_IT_SOURCE\fP(__HANDLE__,  __INTERRUPT__)   ((((__HANDLE__)\->Instance\->CR2 & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)"
.br
.RI "Checks if the specified SMBUS interrupt source is enabled or disabled\&. "
.ti -1c
.RI "#define \fB__HAL_SMBUS_GET_FLAG\fP(__HANDLE__,  __FLAG__)"
.br
.RI "Checks whether the specified SMBUS flag is set or not\&. "
.ti -1c
.RI "#define \fB__HAL_SMBUS_CLEAR_FLAG\fP(__HANDLE__,  __FLAG__)   ((__HANDLE__)\->Instance\->SR1 = ~((__FLAG__) & \fBSMBUS_FLAG_MASK\fP))"
.br
.RI "Clears the SMBUS pending flags which are cleared by writing 0 in a specific bit\&. "
.ti -1c
.RI "#define \fB__HAL_SMBUS_CLEAR_ADDRFLAG\fP(__HANDLE__)"
.br
.RI "Clears the SMBUS ADDR pending flag\&. "
.ti -1c
.RI "#define \fB__HAL_SMBUS_CLEAR_STOPFLAG\fP(__HANDLE__)"
.br
.RI "Clears the SMBUS STOPF pending flag\&. "
.ti -1c
.RI "#define \fB__HAL_SMBUS_ENABLE\fP(__HANDLE__)   ((__HANDLE__)\->Instance\->CR1 |=  I2C_CR1_PE)"
.br
.RI "Enable the SMBUS peripheral\&. "
.ti -1c
.RI "#define \fB__HAL_SMBUS_DISABLE\fP(__HANDLE__)   ((__HANDLE__)\->Instance\->CR1 &=  ~I2C_CR1_PE)"
.br
.RI "Disable the SMBUS peripheral\&. "
.ti -1c
.RI "#define \fB__HAL_SMBUS_GENERATE_NACK\fP(__HANDLE__)   (CLEAR_BIT((__HANDLE__)\->Instance\->CR1, I2C_CR1_ACK))"
.br
.RI "Generate a Non-Acknowledge SMBUS peripheral in Slave mode\&. "
.in -1c
.SH "详细描述"
.PP 

.SH "宏定义说明"
.PP 
.SS "#define __HAL_SMBUS_CLEAR_ADDRFLAG(__HANDLE__)"
\fB值:\fP
.PP
.nf
  do{                                           \
    __IO uint32_t tmpreg = 0x00U;               \
    tmpreg = (__HANDLE__)->Instance->SR1;       \
    tmpreg = (__HANDLE__)->Instance->SR2;       \
    UNUSED(tmpreg);                             \
  } while(0)
.fi
.PP
Clears the SMBUS ADDR pending flag\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the SMBUS Handle\&. This parameter can be SMBUS where x: 1, 2, or 3 to select the SMBUS peripheral\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_smbus\&.h 第 483 行定义\&.
.SS "#define __HAL_SMBUS_CLEAR_FLAG(__HANDLE__, __FLAG__)   ((__HANDLE__)\->Instance\->SR1 = ~((__FLAG__) & \fBSMBUS_FLAG_MASK\fP))"

.PP
Clears the SMBUS pending flags which are cleared by writing 0 in a specific bit\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the SMBUS Handle\&. This parameter can be SMBUS where x: 1, 2, or 3 to select the SMBUS peripheral\&. 
.br
\fI<strong>FLAG</strong>\fP specifies the flag to clear\&. This parameter can be any combination of the following values: 
.PD 0

.IP "\(bu" 2
SMBUS_FLAG_SMBALERT: SMBus Alert flag 
.IP "\(bu" 2
SMBUS_FLAG_TIMEOUT: Timeout or Tlow error flag 
.IP "\(bu" 2
SMBUS_FLAG_PECERR: PEC error in reception flag 
.IP "\(bu" 2
SMBUS_FLAG_OVR: Overrun/Underrun flag (Slave mode) 
.IP "\(bu" 2
SMBUS_FLAG_AF: Acknowledge failure flag 
.IP "\(bu" 2
SMBUS_FLAG_ARLO: Arbitration lost flag (Master mode) 
.IP "\(bu" 2
SMBUS_FLAG_BERR: Bus error flag 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_smbus\&.h 第 476 行定义\&.
.SS "#define __HAL_SMBUS_CLEAR_STOPFLAG(__HANDLE__)"
\fB值:\fP
.PP
.nf
  do{                                           \
    __IO uint32_t tmpreg = 0x00U;               \
    tmpreg = (__HANDLE__)->Instance->SR1;       \
    (__HANDLE__)->Instance->CR1 |= I2C_CR1_PE;  \
    UNUSED(tmpreg);                             \
  } while(0)
.fi
.PP
Clears the SMBUS STOPF pending flag\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the SMBUS Handle\&. This parameter can be SMBUS where x: 1, 2, or 3 to select the SMBUS peripheral\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_smbus\&.h 第 496 行定义\&.
.SS "#define __HAL_SMBUS_DISABLE(__HANDLE__)   ((__HANDLE__)\->Instance\->CR1 &=  ~I2C_CR1_PE)"

.PP
Disable the SMBUS peripheral\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the SMBUS Handle\&. This parameter can be SMBUSx where x: 1 or 2 to select the SMBUS peripheral\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_smbus\&.h 第 516 行定义\&.
.SS "#define __HAL_SMBUS_DISABLE_IT(__HANDLE__, __INTERRUPT__)   ((__HANDLE__)\->Instance\->CR2 &= (~(__INTERRUPT__)))"

.PP
在文件 stm32f4xx_hal_smbus\&.h 第 416 行定义\&.
.SS "#define __HAL_SMBUS_ENABLE(__HANDLE__)   ((__HANDLE__)\->Instance\->CR1 |=  I2C_CR1_PE)"

.PP
Enable the SMBUS peripheral\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the SMBUS Handle\&. This parameter can be SMBUSx where x: 1 or 2 to select the SMBUS peripheral\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_smbus\&.h 第 509 行定义\&.
.SS "#define __HAL_SMBUS_ENABLE_IT(__HANDLE__, __INTERRUPT__)   ((__HANDLE__)\->Instance\->CR2 |= (__INTERRUPT__))"

.PP
Enable or disable the specified SMBUS interrupts\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the SMBUS Handle\&. This parameter can be SMBUS where x: 1, 2, or 3 to select the SMBUS peripheral\&. 
.br
\fI<strong>INTERRUPT</strong>\fP specifies the interrupt source to enable or disable\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
SMBUS_IT_BUF: Buffer interrupt enable 
.IP "\(bu" 2
SMBUS_IT_EVT: Event interrupt enable 
.IP "\(bu" 2
SMBUS_IT_ERR: Error interrupt enable 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_smbus\&.h 第 415 行定义\&.
.SS "#define __HAL_SMBUS_GENERATE_NACK(__HANDLE__)   (CLEAR_BIT((__HANDLE__)\->Instance\->CR1, I2C_CR1_ACK))"

.PP
Generate a Non-Acknowledge SMBUS peripheral in Slave mode\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the SMBUS Handle\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_smbus\&.h 第 522 行定义\&.
.SS "#define __HAL_SMBUS_GET_FLAG(__HANDLE__, __FLAG__)"
\fB值:\fP
.PP
.nf
                                                 ((((uint8_t)((__FLAG__) >> 16U)) == 0x01U)?((((__HANDLE__)->Instance->SR1) & ((__FLAG__) & SMBUS_FLAG_MASK)) == ((__FLAG__) & SMBUS_FLAG_MASK)): \
                                                 ((((__HANDLE__)->Instance->SR2) & ((__FLAG__) & SMBUS_FLAG_MASK)) == ((__FLAG__) & SMBUS_FLAG_MASK)))
.fi
.PP
Checks whether the specified SMBUS flag is set or not\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the SMBUS Handle\&. This parameter can be SMBUS where x: 1, 2, or 3 to select the SMBUS peripheral\&. 
.br
\fI<strong>FLAG</strong>\fP specifies the flag to check\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
SMBUS_FLAG_SMBALERT: SMBus Alert flag 
.IP "\(bu" 2
SMBUS_FLAG_TIMEOUT: Timeout or Tlow error flag 
.IP "\(bu" 2
SMBUS_FLAG_PECERR: PEC error in reception flag 
.IP "\(bu" 2
SMBUS_FLAG_OVR: Overrun/Underrun flag 
.IP "\(bu" 2
SMBUS_FLAG_AF: Acknowledge failure flag 
.IP "\(bu" 2
SMBUS_FLAG_ARLO: Arbitration lost flag 
.IP "\(bu" 2
SMBUS_FLAG_BERR: Bus error flag 
.IP "\(bu" 2
SMBUS_FLAG_TXE: Data register empty flag 
.IP "\(bu" 2
SMBUS_FLAG_RXNE: Data register not empty flag 
.IP "\(bu" 2
SMBUS_FLAG_STOPF: Stop detection flag 
.IP "\(bu" 2
SMBUS_FLAG_ADD10: 10-bit header sent flag 
.IP "\(bu" 2
SMBUS_FLAG_BTF: Byte transfer finished flag 
.IP "\(bu" 2
SMBUS_FLAG_ADDR: Address sent flag Address matched flag 
.IP "\(bu" 2
SMBUS_FLAG_SB: Start bit flag 
.IP "\(bu" 2
SMBUS_FLAG_DUALF: Dual flag 
.IP "\(bu" 2
SMBUS_FLAG_SMBHOST: SMBus host header 
.IP "\(bu" 2
SMBUS_FLAG_SMBDEFAULT: SMBus default header 
.IP "\(bu" 2
SMBUS_FLAG_GENCALL: General call header flag 
.IP "\(bu" 2
SMBUS_FLAG_TRA: Transmitter/Receiver flag 
.IP "\(bu" 2
SMBUS_FLAG_BUSY: Bus busy flag 
.IP "\(bu" 2
SMBUS_FLAG_MSL: Master/Slave flag 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fIThe\fP new state of \fBFLAG\fP (TRUE or FALSE)\&. 
.RE
.PP

.PP
在文件 stm32f4xx_hal_smbus\&.h 第 459 行定义\&.
.SS "#define __HAL_SMBUS_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)   ((((__HANDLE__)\->Instance\->CR2 & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)"

.PP
Checks if the specified SMBUS interrupt source is enabled or disabled\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the SMBUS Handle\&. This parameter can be SMBUS where x: 1, 2, or 3 to select the SMBUS peripheral\&. 
.br
\fI<strong>INTERRUPT</strong>\fP specifies the SMBUS interrupt source to check\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
SMBUS_IT_BUF: Buffer interrupt enable 
.IP "\(bu" 2
SMBUS_IT_EVT: Event interrupt enable 
.IP "\(bu" 2
SMBUS_IT_ERR: Error interrupt enable 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fIThe\fP new state of \fBINTERRUPT\fP (TRUE or FALSE)\&. 
.RE
.PP

.PP
在文件 stm32f4xx_hal_smbus\&.h 第 428 行定义\&.
.SS "#define __HAL_SMBUS_RESET_HANDLE_STATE(__HANDLE__)   ((__HANDLE__)\->State = \fBHAL_SMBUS_STATE_RESET\fP)"

.PP
Reset SMBUS handle state 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the SMBUS Handle\&. This parameter can be SMBUS where x: 1, 2, or 3 to select the SMBUS peripheral\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_smbus\&.h 第 402 行定义\&.
.SH "作者"
.PP 
由 Doyxgen 通过分析 STM32F4_HAL 的 源代码自动生成\&.
