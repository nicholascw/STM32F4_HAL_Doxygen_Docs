.TH "TIM_Exported_Macros" 3 "2020年 八月 7日 星期五" "Version 1.24.0" "STM32F4_HAL" \" -*- nroff -*-
.ad l
.nh
.SH NAME
TIM_Exported_Macros
.SH SYNOPSIS
.br
.PP
.SS "宏定义"

.in +1c
.ti -1c
.RI "#define \fB__HAL_TIM_RESET_HANDLE_STATE\fP(__HANDLE__)   ((__HANDLE__)\->State = \fBHAL_TIM_STATE_RESET\fP)"
.br
.RI "Reset TIM handle state\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_ENABLE\fP(__HANDLE__)   ((__HANDLE__)\->Instance\->CR1|=(TIM_CR1_CEN))"
.br
.RI "Enable the TIM peripheral\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_MOE_ENABLE\fP(__HANDLE__)   ((__HANDLE__)\->Instance\->BDTR|=(TIM_BDTR_MOE))"
.br
.RI "Enable the TIM main Output\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_DISABLE\fP(__HANDLE__)"
.br
.RI "Disable the TIM peripheral\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_MOE_DISABLE\fP(__HANDLE__)"
.br
.RI "Disable the TIM main Output\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_MOE_DISABLE_UNCONDITIONALLY\fP(__HANDLE__)   (__HANDLE__)\->Instance\->BDTR &= ~(TIM_BDTR_MOE)"
.br
.RI "Disable the TIM main Output\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_ENABLE_IT\fP(__HANDLE__,  __INTERRUPT__)   ((__HANDLE__)\->Instance\->DIER |= (__INTERRUPT__))"
.br
.RI "Enable the specified TIM interrupt\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_DISABLE_IT\fP(__HANDLE__,  __INTERRUPT__)   ((__HANDLE__)\->Instance\->DIER &= ~(__INTERRUPT__))"
.br
.RI "Disable the specified TIM interrupt\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_ENABLE_DMA\fP(__HANDLE__,  __DMA__)   ((__HANDLE__)\->Instance\->DIER |= (__DMA__))"
.br
.RI "Enable the specified DMA request\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_DISABLE_DMA\fP(__HANDLE__,  __DMA__)   ((__HANDLE__)\->Instance\->DIER &= ~(__DMA__))"
.br
.RI "Disable the specified DMA request\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_GET_FLAG\fP(__HANDLE__,  __FLAG__)   (((__HANDLE__)\->Instance\->SR &(__FLAG__)) == (__FLAG__))"
.br
.RI "Check whether the specified TIM interrupt flag is set or not\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_CLEAR_FLAG\fP(__HANDLE__,  __FLAG__)   ((__HANDLE__)\->Instance\->SR = ~(__FLAG__))"
.br
.RI "Clear the specified TIM interrupt flag\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_GET_IT_SOURCE\fP(__HANDLE__,  __INTERRUPT__)   ((((__HANDLE__)\->Instance\->DIER & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)"
.br
.RI "Check whether the specified TIM interrupt source is enabled or not\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_CLEAR_IT\fP(__HANDLE__,  __INTERRUPT__)   ((__HANDLE__)\->Instance\->SR = ~(__INTERRUPT__))"
.br
.RI "Clear the TIM interrupt pending bits\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_IS_TIM_COUNTING_DOWN\fP(__HANDLE__)   (((__HANDLE__)\->Instance\->CR1 &(TIM_CR1_DIR)) == (TIM_CR1_DIR))"
.br
.ti -1c
.RI "#define \fB__HAL_TIM_SET_PRESCALER\fP(__HANDLE__,  __PRESC__)   ((__HANDLE__)\->Instance\->PSC = (__PRESC__))"
.br
.RI "Set the TIM Prescaler on runtime\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_SET_COUNTER\fP(__HANDLE__,  __COUNTER__)   ((__HANDLE__)\->Instance\->CNT = (__COUNTER__))"
.br
.RI "Set the TIM Counter Register value on runtime\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_GET_COUNTER\fP(__HANDLE__)   ((__HANDLE__)\->Instance\->CNT)"
.br
.RI "Get the TIM Counter Register value on runtime\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_SET_AUTORELOAD\fP(__HANDLE__,  __AUTORELOAD__)"
.br
.RI "Set the TIM Autoreload Register value on runtime without calling another time any Init function\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_GET_AUTORELOAD\fP(__HANDLE__)   ((__HANDLE__)\->Instance\->ARR)"
.br
.RI "Get the TIM Autoreload Register value on runtime\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_SET_CLOCKDIVISION\fP(__HANDLE__,  __CKD__)"
.br
.RI "Set the TIM Clock Division value on runtime without calling another time any Init function\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_GET_CLOCKDIVISION\fP(__HANDLE__)   ((__HANDLE__)\->Instance\->CR1 & TIM_CR1_CKD)"
.br
.RI "Get the TIM Clock Division value on runtime\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_SET_ICPRESCALER\fP(__HANDLE__,  __CHANNEL__,  __ICPSC__)"
.br
.RI "Set the TIM Input Capture prescaler on runtime without calling another time \fBHAL_TIM_IC_ConfigChannel()\fP function\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_GET_ICPRESCALER\fP(__HANDLE__,  __CHANNEL__)"
.br
.RI "Get the TIM Input Capture prescaler on runtime\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_SET_COMPARE\fP(__HANDLE__,  __CHANNEL__,  __COMPARE__)"
.br
.RI "Set the TIM Capture Compare Register value on runtime without calling another time ConfigChannel function\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_GET_COMPARE\fP(__HANDLE__,  __CHANNEL__)"
.br
.RI "Get the TIM Capture Compare Register value on runtime\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_ENABLE_OCxPRELOAD\fP(__HANDLE__,  __CHANNEL__)"
.br
.RI "Set the TIM Output compare preload\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_DISABLE_OCxPRELOAD\fP(__HANDLE__,  __CHANNEL__)"
.br
.RI "Reset the TIM Output compare preload\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_URS_ENABLE\fP(__HANDLE__)   ((__HANDLE__)\->Instance\->CR1|= TIM_CR1_URS)"
.br
.RI "Set the Update Request Source (URS) bit of the TIMx_CR1 register\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_URS_DISABLE\fP(__HANDLE__)   ((__HANDLE__)\->Instance\->CR1&=~TIM_CR1_URS)"
.br
.RI "Reset the Update Request Source (URS) bit of the TIMx_CR1 register\&. "
.ti -1c
.RI "#define \fB__HAL_TIM_SET_CAPTUREPOLARITY\fP(__HANDLE__,  __CHANNEL__,  __POLARITY__)"
.br
.RI "Set the TIM Capture x input polarity on runtime\&. "
.in -1c
.SH "详细描述"
.PP 

.SH "宏定义说明"
.PP 
.SS "#define __HAL_TIM_CLEAR_FLAG(__HANDLE__, __FLAG__)   ((__HANDLE__)\->Instance\->SR = ~(__FLAG__))"

.PP
Clear the specified TIM interrupt flag\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the TIM Handle\&. 
.br
\fI<strong>FLAG</strong>\fP specifies the TIM interrupt flag to clear\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
TIM_FLAG_UPDATE: Update interrupt flag 
.IP "\(bu" 2
TIM_FLAG_CC1: Capture/Compare 1 interrupt flag 
.IP "\(bu" 2
TIM_FLAG_CC2: Capture/Compare 2 interrupt flag 
.IP "\(bu" 2
TIM_FLAG_CC3: Capture/Compare 3 interrupt flag 
.IP "\(bu" 2
TIM_FLAG_CC4: Capture/Compare 4 interrupt flag 
.IP "\(bu" 2
TIM_FLAG_COM: Commutation interrupt flag 
.IP "\(bu" 2
TIM_FLAG_TRIGGER: Trigger interrupt flag 
.IP "\(bu" 2
TIM_FLAG_BREAK: Break interrupt flag 
.IP "\(bu" 2
TIM_FLAG_CC1OF: Capture/Compare 1 overcapture flag 
.IP "\(bu" 2
TIM_FLAG_CC2OF: Capture/Compare 2 overcapture flag 
.IP "\(bu" 2
TIM_FLAG_CC3OF: Capture/Compare 3 overcapture flag 
.IP "\(bu" 2
TIM_FLAG_CC4OF: Capture/Compare 4 overcapture flag 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fIThe\fP new state of \fBFLAG\fP (TRUE or FALSE)\&. 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1159 行定义\&.
.SS "#define __HAL_TIM_CLEAR_IT(__HANDLE__, __INTERRUPT__)   ((__HANDLE__)\->Instance\->SR = ~(__INTERRUPT__))"

.PP
Clear the TIM interrupt pending bits\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP TIM handle 
.br
\fI<strong>INTERRUPT</strong>\fP specifies the interrupt pending bit to clear\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
TIM_IT_UPDATE: Update interrupt 
.IP "\(bu" 2
TIM_IT_CC1: Capture/Compare 1 interrupt 
.IP "\(bu" 2
TIM_IT_CC2: Capture/Compare 2 interrupt 
.IP "\(bu" 2
TIM_IT_CC3: Capture/Compare 3 interrupt 
.IP "\(bu" 2
TIM_IT_CC4: Capture/Compare 4 interrupt 
.IP "\(bu" 2
TIM_IT_COM: Commutation interrupt 
.IP "\(bu" 2
TIM_IT_TRIGGER: Trigger interrupt 
.IP "\(bu" 2
TIM_IT_BREAK: Break interrupt 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1192 行定义\&.
.SS "#define __HAL_TIM_DISABLE(__HANDLE__)"
\fB值:\fP
.PP
.nf
                        do { \
                          if (((__HANDLE__)->Instance->CCER & TIM_CCER_CCxE_MASK) == 0UL) \
                            { \
                            if(((__HANDLE__)->Instance->CCER & TIM_CCER_CCxNE_MASK) == 0UL) \
                            { \
                              (__HANDLE__)->Instance->CR1 &= ~(TIM_CR1_CEN); \
                            } \
                          } \
                        } while(0)
.fi
.PP
Disable the TIM peripheral\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP TIM handle 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1023 行定义\&.
.SS "#define __HAL_TIM_DISABLE_DMA(__HANDLE__, __DMA__)   ((__HANDLE__)\->Instance\->DIER &= ~(__DMA__))"

.PP
Disable the specified DMA request\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the TIM Handle\&. 
.br
\fI<strong>DMA</strong>\fP specifies the TIM DMA request to disable\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
TIM_DMA_UPDATE: Update DMA request 
.IP "\(bu" 2
TIM_DMA_CC1: Capture/Compare 1 DMA request 
.IP "\(bu" 2
TIM_DMA_CC2: Capture/Compare 2 DMA request 
.IP "\(bu" 2
TIM_DMA_CC3: Capture/Compare 3 DMA request 
.IP "\(bu" 2
TIM_DMA_CC4: Capture/Compare 4 DMA request 
.IP "\(bu" 2
TIM_DMA_COM: Commutation DMA request 
.IP "\(bu" 2
TIM_DMA_TRIGGER: Trigger DMA request 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1119 行定义\&.
.SS "#define __HAL_TIM_DISABLE_IT(__HANDLE__, __INTERRUPT__)   ((__HANDLE__)\->Instance\->DIER &= ~(__INTERRUPT__))"

.PP
Disable the specified TIM interrupt\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the TIM Handle\&. 
.br
\fI<strong>INTERRUPT</strong>\fP specifies the TIM interrupt source to disable\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
TIM_IT_UPDATE: Update interrupt 
.IP "\(bu" 2
TIM_IT_CC1: Capture/Compare 1 interrupt 
.IP "\(bu" 2
TIM_IT_CC2: Capture/Compare 2 interrupt 
.IP "\(bu" 2
TIM_IT_CC3: Capture/Compare 3 interrupt 
.IP "\(bu" 2
TIM_IT_CC4: Capture/Compare 4 interrupt 
.IP "\(bu" 2
TIM_IT_COM: Commutation interrupt 
.IP "\(bu" 2
TIM_IT_TRIGGER: Trigger interrupt 
.IP "\(bu" 2
TIM_IT_BREAK: Break interrupt 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1089 行定义\&.
.SS "#define __HAL_TIM_DISABLE_OCxPRELOAD(__HANDLE__, __CHANNEL__)"
\fB值:\fP
.PP
.nf
        (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 &= (uint16_t)~TIM_CCMR1_OC1PE) :\
         ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 &= (uint16_t)~TIM_CCMR1_OC2PE) :\
         ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 &= (uint16_t)~TIM_CCMR2_OC3PE) :\
         ((__HANDLE__)->Instance->CCMR2 &= (uint16_t)~TIM_CCMR2_OC4PE))
.fi
.PP
Reset the TIM Output compare preload\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP TIM handle\&. 
.br
\fI<strong>CHANNEL</strong>\fP TIM Channels to be configured\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
TIM_CHANNEL_1: TIM Channel 1 selected 
.IP "\(bu" 2
TIM_CHANNEL_2: TIM Channel 2 selected 
.IP "\(bu" 2
TIM_CHANNEL_3: TIM Channel 3 selected 
.IP "\(bu" 2
TIM_CHANNEL_4: TIM Channel 4 selected 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1382 行定义\&.
.SS "#define __HAL_TIM_ENABLE(__HANDLE__)   ((__HANDLE__)\->Instance\->CR1|=(TIM_CR1_CEN))"

.PP
Enable the TIM peripheral\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP TIM handle 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1009 行定义\&.
.SS "#define __HAL_TIM_ENABLE_DMA(__HANDLE__, __DMA__)   ((__HANDLE__)\->Instance\->DIER |= (__DMA__))"

.PP
Enable the specified DMA request\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the TIM Handle\&. 
.br
\fI<strong>DMA</strong>\fP specifies the TIM DMA request to enable\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
TIM_DMA_UPDATE: Update DMA request 
.IP "\(bu" 2
TIM_DMA_CC1: Capture/Compare 1 DMA request 
.IP "\(bu" 2
TIM_DMA_CC2: Capture/Compare 2 DMA request 
.IP "\(bu" 2
TIM_DMA_CC3: Capture/Compare 3 DMA request 
.IP "\(bu" 2
TIM_DMA_CC4: Capture/Compare 4 DMA request 
.IP "\(bu" 2
TIM_DMA_COM: Commutation DMA request 
.IP "\(bu" 2
TIM_DMA_TRIGGER: Trigger DMA request 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1104 行定义\&.
.SS "#define __HAL_TIM_ENABLE_IT(__HANDLE__, __INTERRUPT__)   ((__HANDLE__)\->Instance\->DIER |= (__INTERRUPT__))"

.PP
Enable the specified TIM interrupt\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the TIM Handle\&. 
.br
\fI<strong>INTERRUPT</strong>\fP specifies the TIM interrupt source to enable\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
TIM_IT_UPDATE: Update interrupt 
.IP "\(bu" 2
TIM_IT_CC1: Capture/Compare 1 interrupt 
.IP "\(bu" 2
TIM_IT_CC2: Capture/Compare 2 interrupt 
.IP "\(bu" 2
TIM_IT_CC3: Capture/Compare 3 interrupt 
.IP "\(bu" 2
TIM_IT_CC4: Capture/Compare 4 interrupt 
.IP "\(bu" 2
TIM_IT_COM: Commutation interrupt 
.IP "\(bu" 2
TIM_IT_TRIGGER: Trigger interrupt 
.IP "\(bu" 2
TIM_IT_BREAK: Break interrupt 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1073 行定义\&.
.SS "#define __HAL_TIM_ENABLE_OCxPRELOAD(__HANDLE__, __CHANNEL__)"
\fB值:\fP
.PP
.nf
        (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 |= TIM_CCMR1_OC1PE) :\
         ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCMR1 |= TIM_CCMR1_OC2PE) :\
         ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 |= TIM_CCMR2_OC3PE) :\
         ((__HANDLE__)->Instance->CCMR2 |= TIM_CCMR2_OC4PE))
.fi
.PP
Set the TIM Output compare preload\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP TIM handle\&. 
.br
\fI<strong>CHANNEL</strong>\fP TIM Channels to be configured\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
TIM_CHANNEL_1: TIM Channel 1 selected 
.IP "\(bu" 2
TIM_CHANNEL_2: TIM Channel 2 selected 
.IP "\(bu" 2
TIM_CHANNEL_3: TIM Channel 3 selected 
.IP "\(bu" 2
TIM_CHANNEL_4: TIM Channel 4 selected 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1365 行定义\&.
.SS "#define __HAL_TIM_GET_AUTORELOAD(__HANDLE__)   ((__HANDLE__)\->Instance\->ARR)"

.PP
Get the TIM Autoreload Register value on runtime\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP TIM handle\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fI16-bit\fP or 32-bit value of the timer auto-reload register(TIMx_ARR) 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1244 行定义\&.
.SS "#define __HAL_TIM_GET_CLOCKDIVISION(__HANDLE__)   ((__HANDLE__)\->Instance\->CR1 & TIM_CR1_CKD)"

.PP
Get the TIM Clock Division value on runtime\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP TIM handle\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fIThe\fP clock division can be one of the following values: 
.PD 0

.IP "\(bu" 2
TIM_CLOCKDIVISION_DIV1: tDTS=tCK_INT 
.IP "\(bu" 2
TIM_CLOCKDIVISION_DIV2: tDTS=2*tCK_INT 
.IP "\(bu" 2
TIM_CLOCKDIVISION_DIV4: tDTS=4*tCK_INT 
.PP
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1272 行定义\&.
.SS "#define __HAL_TIM_GET_COMPARE(__HANDLE__, __CHANNEL__)"
\fB值:\fP
.PP
.nf
(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCR1) :\
 ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCR2) :\
 ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCR3) :\
 ((__HANDLE__)->Instance->CCR4))
.fi
.PP
Get the TIM Capture Compare Register value on runtime\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP TIM handle\&. 
.br
\fI<strong>CHANNEL</strong>\fP TIM Channel associated with the capture compare register This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
TIM_CHANNEL_1: get capture/compare 1 register value 
.IP "\(bu" 2
TIM_CHANNEL_2: get capture/compare 2 register value 
.IP "\(bu" 2
TIM_CHANNEL_3: get capture/compare 3 register value 
.IP "\(bu" 2
TIM_CHANNEL_4: get capture/compare 4 register value 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fI16-bit\fP or 32-bit value of the capture/compare register (TIMx_CCRy) 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1348 行定义\&.
.SS "#define __HAL_TIM_GET_COUNTER(__HANDLE__)   ((__HANDLE__)\->Instance\->CNT)"

.PP
Get the TIM Counter Register value on runtime\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP TIM handle\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fI16-bit\fP or 32-bit value of the timer counter register (TIMx_CNT) 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1224 行定义\&.
.SS "#define __HAL_TIM_GET_FLAG(__HANDLE__, __FLAG__)   (((__HANDLE__)\->Instance\->SR &(__FLAG__)) == (__FLAG__))"

.PP
Check whether the specified TIM interrupt flag is set or not\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the TIM Handle\&. 
.br
\fI<strong>FLAG</strong>\fP specifies the TIM interrupt flag to check\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
TIM_FLAG_UPDATE: Update interrupt flag 
.IP "\(bu" 2
TIM_FLAG_CC1: Capture/Compare 1 interrupt flag 
.IP "\(bu" 2
TIM_FLAG_CC2: Capture/Compare 2 interrupt flag 
.IP "\(bu" 2
TIM_FLAG_CC3: Capture/Compare 3 interrupt flag 
.IP "\(bu" 2
TIM_FLAG_CC4: Capture/Compare 4 interrupt flag 
.IP "\(bu" 2
TIM_FLAG_COM: Commutation interrupt flag 
.IP "\(bu" 2
TIM_FLAG_TRIGGER: Trigger interrupt flag 
.IP "\(bu" 2
TIM_FLAG_BREAK: Break interrupt flag 
.IP "\(bu" 2
TIM_FLAG_CC1OF: Capture/Compare 1 overcapture flag 
.IP "\(bu" 2
TIM_FLAG_CC2OF: Capture/Compare 2 overcapture flag 
.IP "\(bu" 2
TIM_FLAG_CC3OF: Capture/Compare 3 overcapture flag 
.IP "\(bu" 2
TIM_FLAG_CC4OF: Capture/Compare 4 overcapture flag 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fIThe\fP new state of \fBFLAG\fP (TRUE or FALSE)\&. 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1139 行定义\&.
.SS "#define __HAL_TIM_GET_ICPRESCALER(__HANDLE__, __CHANNEL__)"
\fB值:\fP
.PP
.nf
  (((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCMR1 & TIM_CCMR1_IC1PSC) :\
   ((__CHANNEL__) == TIM_CHANNEL_2) ? (((__HANDLE__)->Instance->CCMR1 & TIM_CCMR1_IC2PSC) >> 8U) :\
   ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCMR2 & TIM_CCMR2_IC3PSC) :\
   (((__HANDLE__)->Instance->CCMR2 & TIM_CCMR2_IC4PSC)) >> 8U)
.fi
.PP
Get the TIM Input Capture prescaler on runtime\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP TIM handle\&. 
.br
\fI<strong>CHANNEL</strong>\fP TIM Channels to be configured\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
TIM_CHANNEL_1: get input capture 1 prescaler value 
.IP "\(bu" 2
TIM_CHANNEL_2: get input capture 2 prescaler value 
.IP "\(bu" 2
TIM_CHANNEL_3: get input capture 3 prescaler value 
.IP "\(bu" 2
TIM_CHANNEL_4: get input capture 4 prescaler value 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fIThe\fP input capture prescaler can be one of the following values: 
.PD 0

.IP "\(bu" 2
TIM_ICPSC_DIV1: no prescaler 
.IP "\(bu" 2
TIM_ICPSC_DIV2: capture is done once every 2 events 
.IP "\(bu" 2
TIM_ICPSC_DIV4: capture is done once every 4 events 
.IP "\(bu" 2
TIM_ICPSC_DIV8: capture is done once every 8 events 
.PP
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1313 行定义\&.
.SS "#define __HAL_TIM_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)   ((((__HANDLE__)\->Instance\->DIER & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)"

.PP
Check whether the specified TIM interrupt source is enabled or not\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP TIM handle 
.br
\fI<strong>INTERRUPT</strong>\fP specifies the TIM interrupt source to check\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
TIM_IT_UPDATE: Update interrupt 
.IP "\(bu" 2
TIM_IT_CC1: Capture/Compare 1 interrupt 
.IP "\(bu" 2
TIM_IT_CC2: Capture/Compare 2 interrupt 
.IP "\(bu" 2
TIM_IT_CC3: Capture/Compare 3 interrupt 
.IP "\(bu" 2
TIM_IT_CC4: Capture/Compare 4 interrupt 
.IP "\(bu" 2
TIM_IT_COM: Commutation interrupt 
.IP "\(bu" 2
TIM_IT_TRIGGER: Trigger interrupt 
.IP "\(bu" 2
TIM_IT_BREAK: Break interrupt 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fIThe\fP state of TIM_IT (SET or RESET)\&. 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1176 行定义\&.
.SS "#define __HAL_TIM_IS_TIM_COUNTING_DOWN(__HANDLE__)   (((__HANDLE__)\->Instance\->CR1 &(TIM_CR1_DIR)) == (TIM_CR1_DIR))"

.PP
.nf
@brief  Indicates whether or not the TIM Counter is used as downcounter.
@param  __HANDLE__ TIM handle.
@retval False (Counter used as upcounter) or True (Counter used as downcounter)
@note This macro is particularly useful to get the counting mode when the timer operates in Center-aligned mode or Encoder

.fi
.PP
 mode\&. 
.PP
在文件 stm32f4xx_hal_tim\&.h 第 1201 行定义\&.
.SS "#define __HAL_TIM_MOE_DISABLE(__HANDLE__)"
\fB值:\fP
.PP
.nf
                        do { \
                          if (((__HANDLE__)->Instance->CCER & TIM_CCER_CCxE_MASK) == 0UL) \
                          { \
                            if(((__HANDLE__)->Instance->CCER & TIM_CCER_CCxNE_MASK) == 0UL) \
                            { \
                              (__HANDLE__)->Instance->BDTR &= ~(TIM_BDTR_MOE); \
                            } \
                            } \
                        } while(0)
.fi
.PP
Disable the TIM main Output\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP TIM handle 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP
\fB注解\fP
.RS 4
The Main Output Enable of a timer instance is disabled only if all the CCx and CCxN channels have been disabled 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1040 行定义\&.
.SS "#define __HAL_TIM_MOE_DISABLE_UNCONDITIONALLY(__HANDLE__)   (__HANDLE__)\->Instance\->BDTR &= ~(TIM_BDTR_MOE)"

.PP
Disable the TIM main Output\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP TIM handle 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP
\fB注解\fP
.RS 4
The Main Output Enable of a timer instance is disabled unconditionally 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1057 行定义\&.
.SS "#define __HAL_TIM_MOE_ENABLE(__HANDLE__)   ((__HANDLE__)\->Instance\->BDTR|=(TIM_BDTR_MOE))"

.PP
Enable the TIM main Output\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP TIM handle 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1016 行定义\&.
.SS "#define __HAL_TIM_RESET_HANDLE_STATE(__HANDLE__)   ((__HANDLE__)\->State = \fBHAL_TIM_STATE_RESET\fP)"

.PP
Reset TIM handle state\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP TIM handle\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1001 行定义\&.
.SS "#define __HAL_TIM_SET_AUTORELOAD(__HANDLE__, __AUTORELOAD__)"
\fB值:\fP
.PP
.nf
                        do{                                                    \
                              (__HANDLE__)->Instance->ARR = (__AUTORELOAD__);  \
                              (__HANDLE__)->Init\&.Period = (__AUTORELOAD__);    \
                          } while(0)
.fi
.PP
Set the TIM Autoreload Register value on runtime without calling another time any Init function\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP TIM handle\&. 
.br
\fI<strong>AUTORELOAD</strong>\fP specifies the Counter register new value\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1233 行定义\&.
.SS "#define __HAL_TIM_SET_CAPTUREPOLARITY(__HANDLE__, __CHANNEL__, __POLARITY__)"
\fB值:\fP
.PP
.nf
        do{                                                                     \
          TIM_RESET_CAPTUREPOLARITY((__HANDLE__), (__CHANNEL__));               \
          TIM_SET_CAPTUREPOLARITY((__HANDLE__), (__CHANNEL__), (__POLARITY__)); \
        }while(0)
.fi
.PP
Set the TIM Capture x input polarity on runtime\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP TIM handle\&. 
.br
\fI<strong>CHANNEL</strong>\fP TIM Channels to be configured\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
TIM_CHANNEL_1: TIM Channel 1 selected 
.IP "\(bu" 2
TIM_CHANNEL_2: TIM Channel 2 selected 
.IP "\(bu" 2
TIM_CHANNEL_3: TIM Channel 3 selected 
.IP "\(bu" 2
TIM_CHANNEL_4: TIM Channel 4 selected 
.PP
.br
\fI<strong>POLARITY</strong>\fP Polarity for TIx source 
.PD 0

.IP "\(bu" 2
TIM_INPUTCHANNELPOLARITY_RISING: Rising Edge 
.IP "\(bu" 2
TIM_INPUTCHANNELPOLARITY_FALLING: Falling Edge 
.IP "\(bu" 2
TIM_INPUTCHANNELPOLARITY_BOTHEDGE: Rising and Falling Edge 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1428 行定义\&.
.SS "#define __HAL_TIM_SET_CLOCKDIVISION(__HANDLE__, __CKD__)"
\fB值:\fP
.PP
.nf
                        do{                                                   \
                              (__HANDLE__)->Instance->CR1 &= (~TIM_CR1_CKD);  \
                              (__HANDLE__)->Instance->CR1 |= (__CKD__);       \
                              (__HANDLE__)->Init\&.ClockDivision = (__CKD__);   \
                          } while(0)
.fi
.PP
Set the TIM Clock Division value on runtime without calling another time any Init function\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP TIM handle\&. 
.br
\fI<strong>CKD</strong>\fP specifies the clock division value\&. This parameter can be one of the following value: 
.PD 0

.IP "\(bu" 2
TIM_CLOCKDIVISION_DIV1: tDTS=tCK_INT 
.IP "\(bu" 2
TIM_CLOCKDIVISION_DIV2: tDTS=2*tCK_INT 
.IP "\(bu" 2
TIM_CLOCKDIVISION_DIV4: tDTS=4*tCK_INT 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1257 行定义\&.
.SS "#define __HAL_TIM_SET_COMPARE(__HANDLE__, __CHANNEL__, __COMPARE__)"
\fB值:\fP
.PP
.nf
(((__CHANNEL__) == TIM_CHANNEL_1) ? ((__HANDLE__)->Instance->CCR1 = (__COMPARE__)) :\
 ((__CHANNEL__) == TIM_CHANNEL_2) ? ((__HANDLE__)->Instance->CCR2 = (__COMPARE__)) :\
 ((__CHANNEL__) == TIM_CHANNEL_3) ? ((__HANDLE__)->Instance->CCR3 = (__COMPARE__)) :\
 ((__HANDLE__)->Instance->CCR4 = (__COMPARE__)))
.fi
.PP
Set the TIM Capture Compare Register value on runtime without calling another time ConfigChannel function\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP TIM handle\&. 
.br
\fI<strong>CHANNEL</strong>\fP TIM Channels to be configured\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
TIM_CHANNEL_1: TIM Channel 1 selected 
.IP "\(bu" 2
TIM_CHANNEL_2: TIM Channel 2 selected 
.IP "\(bu" 2
TIM_CHANNEL_3: TIM Channel 3 selected 
.IP "\(bu" 2
TIM_CHANNEL_4: TIM Channel 4 selected 
.PP
.br
\fI<strong>COMPARE</strong>\fP specifies the Capture Compare register new value\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1331 行定义\&.
.SS "#define __HAL_TIM_SET_COUNTER(__HANDLE__, __COUNTER__)   ((__HANDLE__)\->Instance\->CNT = (__COUNTER__))"

.PP
Set the TIM Counter Register value on runtime\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP TIM handle\&. 
.br
\fI<strong>COUNTER</strong>\fP specifies the Counter register new value\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1217 行定义\&.
.SS "#define __HAL_TIM_SET_ICPRESCALER(__HANDLE__, __CHANNEL__, __ICPSC__)"
\fB值:\fP
.PP
.nf
                        do{                                                    \
                              TIM_RESET_ICPRESCALERVALUE((__HANDLE__), (__CHANNEL__));  \
                              TIM_SET_ICPRESCALERVALUE((__HANDLE__), (__CHANNEL__), (__ICPSC__)); \
                          } while(0)
.fi
.PP
Set the TIM Input Capture prescaler on runtime without calling another time \fBHAL_TIM_IC_ConfigChannel()\fP function\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP TIM handle\&. 
.br
\fI<strong>CHANNEL</strong>\fP TIM Channels to be configured\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
TIM_CHANNEL_1: TIM Channel 1 selected 
.IP "\(bu" 2
TIM_CHANNEL_2: TIM Channel 2 selected 
.IP "\(bu" 2
TIM_CHANNEL_3: TIM Channel 3 selected 
.IP "\(bu" 2
TIM_CHANNEL_4: TIM Channel 4 selected 
.PP
.br
\fI<strong>ICPSC</strong>\fP specifies the Input Capture4 prescaler new value\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
TIM_ICPSC_DIV1: no prescaler 
.IP "\(bu" 2
TIM_ICPSC_DIV2: capture is done once every 2 events 
.IP "\(bu" 2
TIM_ICPSC_DIV4: capture is done once every 4 events 
.IP "\(bu" 2
TIM_ICPSC_DIV8: capture is done once every 8 events 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1292 行定义\&.
.SS "#define __HAL_TIM_SET_PRESCALER(__HANDLE__, __PRESC__)   ((__HANDLE__)\->Instance\->PSC = (__PRESC__))"

.PP
Set the TIM Prescaler on runtime\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP TIM handle\&. 
.br
\fI<strong>PRESC</strong>\fP specifies the Prescaler new value\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1209 行定义\&.
.SS "#define __HAL_TIM_URS_DISABLE(__HANDLE__)   ((__HANDLE__)\->Instance\->CR1&=~TIM_CR1_URS)"

.PP
Reset the Update Request Source (URS) bit of the TIMx_CR1 register\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP TIM handle\&. 
.RE
.PP
\fB注解\fP
.RS 4
When the URS bit of the TIMx_CR1 register is reset, any of the following events generate an update interrupt or DMA request (if enabled): _ Counter overflow underflow _ Setting the UG bit _ Update generation through the slave mode controller 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1410 行定义\&.
.SS "#define __HAL_TIM_URS_ENABLE(__HANDLE__)   ((__HANDLE__)\->Instance\->CR1|= TIM_CR1_URS)"

.PP
Set the Update Request Source (URS) bit of the TIMx_CR1 register\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP TIM handle\&. 
.RE
.PP
\fB注解\fP
.RS 4
When the URS bit of the TIMx_CR1 register is set, only counter overflow/underflow generates an update interrupt or DMA request (if enabled) 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_tim\&.h 第 1396 行定义\&.
.SH "作者"
.PP 
由 Doyxgen 通过分析 STM32F4_HAL 的 源代码自动生成\&.
