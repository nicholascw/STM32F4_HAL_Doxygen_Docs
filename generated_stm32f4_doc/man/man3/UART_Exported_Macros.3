.TH "UART_Exported_Macros" 3 "2020年 八月 7日 星期五" "Version 1.24.0" "STM32F4_HAL" \" -*- nroff -*-
.ad l
.nh
.SH NAME
UART_Exported_Macros
.SH SYNOPSIS
.br
.PP
.SS "宏定义"

.in +1c
.ti -1c
.RI "#define \fB__HAL_UART_RESET_HANDLE_STATE\fP(__HANDLE__)"
.br
.RI "Reset UART handle gstate & RxState "
.ti -1c
.RI "#define \fB__HAL_UART_FLUSH_DRREGISTER\fP(__HANDLE__)   ((__HANDLE__)\->Instance\->DR)"
.br
.RI "Flushes the UART DR register "
.ti -1c
.RI "#define \fB__HAL_UART_GET_FLAG\fP(__HANDLE__,  __FLAG__)   (((__HANDLE__)\->Instance\->SR & (__FLAG__)) == (__FLAG__))"
.br
.RI "Checks whether the specified UART flag is set or not\&. "
.ti -1c
.RI "#define \fB__HAL_UART_CLEAR_FLAG\fP(__HANDLE__,  __FLAG__)   ((__HANDLE__)\->Instance\->SR = ~(__FLAG__))"
.br
.RI "Clears the specified UART pending flag\&. "
.ti -1c
.RI "#define \fB__HAL_UART_CLEAR_PEFLAG\fP(__HANDLE__)"
.br
.RI "Clears the UART PE pending flag\&. "
.ti -1c
.RI "#define \fB__HAL_UART_CLEAR_FEFLAG\fP(__HANDLE__)   \fB__HAL_UART_CLEAR_PEFLAG\fP(__HANDLE__)"
.br
.RI "Clears the UART FE pending flag\&. "
.ti -1c
.RI "#define \fB__HAL_UART_CLEAR_NEFLAG\fP(__HANDLE__)   \fB__HAL_UART_CLEAR_PEFLAG\fP(__HANDLE__)"
.br
.RI "Clears the UART NE pending flag\&. "
.ti -1c
.RI "#define \fB__HAL_UART_CLEAR_OREFLAG\fP(__HANDLE__)   \fB__HAL_UART_CLEAR_PEFLAG\fP(__HANDLE__)"
.br
.RI "Clears the UART ORE pending flag\&. "
.ti -1c
.RI "#define \fB__HAL_UART_CLEAR_IDLEFLAG\fP(__HANDLE__)   \fB__HAL_UART_CLEAR_PEFLAG\fP(__HANDLE__)"
.br
.RI "Clears the UART IDLE pending flag\&. "
.ti -1c
.RI "#define \fB__HAL_UART_ENABLE_IT\fP(__HANDLE__,  __INTERRUPT__)"
.br
.RI "Enable the specified UART interrupt\&. "
.ti -1c
.RI "#define \fB__HAL_UART_DISABLE_IT\fP(__HANDLE__,  __INTERRUPT__)"
.br
.RI "Disable the specified UART interrupt\&. "
.ti -1c
.RI "#define \fB__HAL_UART_GET_IT_SOURCE\fP(__HANDLE__,  __IT__)"
.br
.RI "Checks whether the specified UART interrupt has occurred or not\&. "
.ti -1c
.RI "#define \fB__HAL_UART_HWCONTROL_CTS_ENABLE\fP(__HANDLE__)"
.br
.RI "Enable CTS flow control "
.ti -1c
.RI "#define \fB__HAL_UART_HWCONTROL_CTS_DISABLE\fP(__HANDLE__)"
.br
.RI "Disable CTS flow control "
.ti -1c
.RI "#define \fB__HAL_UART_HWCONTROL_RTS_ENABLE\fP(__HANDLE__)"
.br
.RI "Enable RTS flow control This macro allows to enable RTS hardware flow control for a given UART instance, without need to call \fBHAL_UART_Init()\fP function\&. As involving direct access to UART registers, usage of this macro should be fully endorsed by user\&. "
.ti -1c
.RI "#define \fB__HAL_UART_HWCONTROL_RTS_DISABLE\fP(__HANDLE__)"
.br
.RI "Disable RTS flow control This macro allows to disable RTS hardware flow control for a given UART instance, without need to call \fBHAL_UART_Init()\fP function\&. As involving direct access to UART registers, usage of this macro should be fully endorsed by user\&. "
.ti -1c
.RI "#define \fB__HAL_UART_ONE_BIT_SAMPLE_ENABLE\fP(__HANDLE__)   ((__HANDLE__)\->Instance\->CR3|= USART_CR3_ONEBIT)"
.br
.RI "Macro to enable the UART's one bit sample method "
.ti -1c
.RI "#define \fB__HAL_UART_ONE_BIT_SAMPLE_DISABLE\fP(__HANDLE__)   ((__HANDLE__)\->Instance\->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT))"
.br
.RI "Macro to disable the UART's one bit sample method "
.ti -1c
.RI "#define \fB__HAL_UART_ENABLE\fP(__HANDLE__)   ((__HANDLE__)\->Instance\->CR1 |=  USART_CR1_UE)"
.br
.RI "Enable UART "
.ti -1c
.RI "#define \fB__HAL_UART_DISABLE\fP(__HANDLE__)   ((__HANDLE__)\->Instance\->CR1 &=  ~USART_CR1_UE)"
.br
.RI "Disable UART "
.in -1c
.SH "详细描述"
.PP 

.SH "宏定义说明"
.PP 
.SS "#define __HAL_UART_CLEAR_FEFLAG(__HANDLE__)   \fB__HAL_UART_CLEAR_PEFLAG\fP(__HANDLE__)"

.PP
Clears the UART FE pending flag\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the UART Handle\&. UART Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_uart\&.h 第 473 行定义\&.
.SS "#define __HAL_UART_CLEAR_FLAG(__HANDLE__, __FLAG__)   ((__HANDLE__)\->Instance\->SR = ~(__FLAG__))"

.PP
Clears the specified UART pending flag\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the UART Handle\&. UART Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.br
\fI<strong>FLAG</strong>\fP specifies the flag to check\&. This parameter can be any combination of the following values: 
.PD 0

.IP "\(bu" 2
UART_FLAG_CTS: CTS Change flag (not available for UART4 and UART5)\&. 
.IP "\(bu" 2
UART_FLAG_LBD: LIN Break detection flag\&. 
.IP "\(bu" 2
UART_FLAG_TC: Transmission Complete flag\&. 
.IP "\(bu" 2
UART_FLAG_RXNE: Receive data register not empty flag\&.
.PP
.RE
.PP
\fB注解\fP
.RS 4
PE (Parity error), FE (Framing error), NE (Noise error), ORE (Overrun error) and IDLE (Idle line detected) flags are cleared by software sequence: a read operation to USART_SR register followed by a read operation to USART_DR register\&. 
.PP
RXNE flag can be also cleared by a read to the USART_DR register\&. 
.PP
TC flag can be also cleared by software sequence: a read operation to USART_SR register followed by a write operation to USART_DR register\&. 
.PP
TXE flag is cleared only by a write to the USART_DR register\&.
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_uart\&.h 第 451 行定义\&.
.SS "#define __HAL_UART_CLEAR_IDLEFLAG(__HANDLE__)   \fB__HAL_UART_CLEAR_PEFLAG\fP(__HANDLE__)"

.PP
Clears the UART IDLE pending flag\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the UART Handle\&. UART Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_uart\&.h 第 497 行定义\&.
.SS "#define __HAL_UART_CLEAR_NEFLAG(__HANDLE__)   \fB__HAL_UART_CLEAR_PEFLAG\fP(__HANDLE__)"

.PP
Clears the UART NE pending flag\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the UART Handle\&. UART Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_uart\&.h 第 481 行定义\&.
.SS "#define __HAL_UART_CLEAR_OREFLAG(__HANDLE__)   \fB__HAL_UART_CLEAR_PEFLAG\fP(__HANDLE__)"

.PP
Clears the UART ORE pending flag\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the UART Handle\&. UART Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_uart\&.h 第 489 行定义\&.
.SS "#define __HAL_UART_CLEAR_PEFLAG(__HANDLE__)"
\fB值:\fP
.PP
.nf
  do{                                           \
    __IO uint32_t tmpreg = 0x00U;               \
    tmpreg = (__HANDLE__)->Instance->SR;        \
    tmpreg = (__HANDLE__)->Instance->DR;        \
    UNUSED(tmpreg);                             \
  } while(0U)
.fi
.PP
Clears the UART PE pending flag\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the UART Handle\&. UART Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_uart\&.h 第 459 行定义\&.
.SS "#define __HAL_UART_DISABLE(__HANDLE__)   ((__HANDLE__)\->Instance\->CR1 &=  ~USART_CR1_UE)"

.PP
Disable UART 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the UART Handle\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_uart\&.h 第 659 行定义\&.
.SS "#define __HAL_UART_DISABLE_IT(__HANDLE__, __INTERRUPT__)"
\fB值:\fP
.PP
.nf
                                                           ((((__INTERRUPT__) >> 28U) == UART_CR1_REG_INDEX)? ((__HANDLE__)->Instance->CR1 &= ~((__INTERRUPT__) & UART_IT_MASK)): \
                                                           (((__INTERRUPT__) >> 28U) == UART_CR2_REG_INDEX)? ((__HANDLE__)->Instance->CR2 &= ~((__INTERRUPT__) & UART_IT_MASK)): \
                                                           ((__HANDLE__)->Instance->CR3 &= ~ ((__INTERRUPT__) & UART_IT_MASK)))
.fi
.PP
Disable the specified UART interrupt\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the UART Handle\&. UART Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.br
\fI<strong>INTERRUPT</strong>\fP specifies the UART interrupt source to disable\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
UART_IT_CTS: CTS change interrupt 
.IP "\(bu" 2
UART_IT_LBD: LIN Break detection interrupt 
.IP "\(bu" 2
UART_IT_TXE: Transmit Data Register empty interrupt 
.IP "\(bu" 2
UART_IT_TC: Transmission complete interrupt 
.IP "\(bu" 2
UART_IT_RXNE: Receive Data register not empty interrupt 
.IP "\(bu" 2
UART_IT_IDLE: Idle line detection interrupt 
.IP "\(bu" 2
UART_IT_PE: Parity Error interrupt 
.IP "\(bu" 2
UART_IT_ERR: Error interrupt(Frame error, noise error, overrun error) 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_uart\&.h 第 535 行定义\&.
.SS "#define __HAL_UART_ENABLE(__HANDLE__)   ((__HANDLE__)\->Instance\->CR1 |=  USART_CR1_UE)"

.PP
Enable UART 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the UART Handle\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_uart\&.h 第 653 行定义\&.
.SS "#define __HAL_UART_ENABLE_IT(__HANDLE__, __INTERRUPT__)"
\fB值:\fP
.PP
.nf
                                                           ((((__INTERRUPT__) >> 28U) == UART_CR1_REG_INDEX)? ((__HANDLE__)->Instance->CR1 |= ((__INTERRUPT__) & UART_IT_MASK)): \
                                                           (((__INTERRUPT__) >> 28U) == UART_CR2_REG_INDEX)? ((__HANDLE__)->Instance->CR2 |= ((__INTERRUPT__) & UART_IT_MASK)): \
                                                           ((__HANDLE__)->Instance->CR3 |= ((__INTERRUPT__) & UART_IT_MASK)))
.fi
.PP
Enable the specified UART interrupt\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the UART Handle\&. UART Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.br
\fI<strong>INTERRUPT</strong>\fP specifies the UART interrupt source to enable\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
UART_IT_CTS: CTS change interrupt 
.IP "\(bu" 2
UART_IT_LBD: LIN Break detection interrupt 
.IP "\(bu" 2
UART_IT_TXE: Transmit Data Register empty interrupt 
.IP "\(bu" 2
UART_IT_TC: Transmission complete interrupt 
.IP "\(bu" 2
UART_IT_RXNE: Receive Data register not empty interrupt 
.IP "\(bu" 2
UART_IT_IDLE: Idle line detection interrupt 
.IP "\(bu" 2
UART_IT_PE: Parity Error interrupt 
.IP "\(bu" 2
UART_IT_ERR: Error interrupt(Frame error, noise error, overrun error) 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_uart\&.h 第 515 行定义\&.
.SS "#define __HAL_UART_FLUSH_DRREGISTER(__HANDLE__)   ((__HANDLE__)\->Instance\->DR)"

.PP
Flushes the UART DR register 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the UART Handle\&. UART Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.RE
.PP

.PP
在文件 stm32f4xx_hal_uart\&.h 第 407 行定义\&.
.SS "#define __HAL_UART_GET_FLAG(__HANDLE__, __FLAG__)   (((__HANDLE__)\->Instance\->SR & (__FLAG__)) == (__FLAG__))"

.PP
Checks whether the specified UART flag is set or not\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the UART Handle\&. UART Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.br
\fI<strong>FLAG</strong>\fP specifies the flag to check\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
UART_FLAG_CTS: CTS Change flag (not available for UART4 and UART5) 
.IP "\(bu" 2
UART_FLAG_LBD: LIN Break detection flag 
.IP "\(bu" 2
UART_FLAG_TXE: Transmit data register empty flag 
.IP "\(bu" 2
UART_FLAG_TC: Transmission Complete flag 
.IP "\(bu" 2
UART_FLAG_RXNE: Receive data register not empty flag 
.IP "\(bu" 2
UART_FLAG_IDLE: Idle Line detection flag 
.IP "\(bu" 2
UART_FLAG_ORE: Overrun Error flag 
.IP "\(bu" 2
UART_FLAG_NE: Noise Error flag 
.IP "\(bu" 2
UART_FLAG_FE: Framing Error flag 
.IP "\(bu" 2
UART_FLAG_PE: Parity Error flag 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fIThe\fP new state of \fBFLAG\fP (TRUE or FALSE)\&. 
.RE
.PP

.PP
在文件 stm32f4xx_hal_uart\&.h 第 427 行定义\&.
.SS "#define __HAL_UART_GET_IT_SOURCE(__HANDLE__, __IT__)"
\fB值:\fP
.PP
.nf
                                                      (((((__IT__) >> 28U) == UART_CR1_REG_INDEX)? (__HANDLE__)->Instance->CR1:(((((uint32_t)(__IT__)) >> 28U) == UART_CR2_REG_INDEX)? \
                                                      (__HANDLE__)->Instance->CR2 : (__HANDLE__)->Instance->CR3)) & (((uint32_t)(__IT__)) & UART_IT_MASK))
.fi
.PP
Checks whether the specified UART interrupt has occurred or not\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the UART Handle\&. UART Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.br
\fI<strong>IT</strong>\fP specifies the UART interrupt source to check\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
UART_IT_CTS: CTS change interrupt (not available for UART4 and UART5) 
.IP "\(bu" 2
UART_IT_LBD: LIN Break detection interrupt 
.IP "\(bu" 2
UART_IT_TXE: Transmit Data Register empty interrupt 
.IP "\(bu" 2
UART_IT_TC: Transmission complete interrupt 
.IP "\(bu" 2
UART_IT_RXNE: Receive Data register not empty interrupt 
.IP "\(bu" 2
UART_IT_IDLE: Idle line detection interrupt 
.IP "\(bu" 2
UART_IT_ERR: Error interrupt 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fIThe\fP new state of \fBIT\fP (TRUE or FALSE)\&. 
.RE
.PP

.PP
在文件 stm32f4xx_hal_uart\&.h 第 554 行定义\&.
.SS "#define __HAL_UART_HWCONTROL_CTS_DISABLE(__HANDLE__)"
\fB值:\fP
.PP
.nf
  do{                                                       \
    CLEAR_BIT((__HANDLE__)->Instance->CR3, USART_CR3_CTSE); \
    (__HANDLE__)->Init\&.HwFlowCtl &= ~(USART_CR3_CTSE);      \
  } while(0U)
.fi
.PP
Disable CTS flow control 
.PP
\fB注解\fP
.RS 4
This macro allows to disable CTS hardware flow control for a given UART instance, without need to call \fBHAL_UART_Init()\fP function\&. As involving direct access to UART registers, usage of this macro should be fully endorsed by user\&. 
.PP
As macro is expected to be used for modifying CTS Hw flow control feature activation, without need for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
.IP "\(bu" 2
UART instance should have already been initialised (through call of \fBHAL_UART_Init()\fP )
.IP "\(bu" 2
macro could only be called when corresponding UART instance is disabled (i\&.e \fBHAL_UART_DISABLE(__HANDLE\fP)) and should be followed by an Enable macro (i\&.e \fBHAL_UART_ENABLE(__HANDLE\fP))\&. 
.PP
.RE
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the UART Handle\&. The Handle Instance can be any USARTx (supporting the HW Flow control feature)\&. It is used to select the USART peripheral (USART availability and x value depending on device)\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_uart\&.h 第 591 行定义\&.
.SS "#define __HAL_UART_HWCONTROL_CTS_ENABLE(__HANDLE__)"
\fB值:\fP
.PP
.nf
  do{                                                      \
    SET_BIT((__HANDLE__)->Instance->CR3, USART_CR3_CTSE);  \
    (__HANDLE__)->Init\&.HwFlowCtl |= USART_CR3_CTSE;        \
  } while(0U)
.fi
.PP
Enable CTS flow control 
.PP
\fB注解\fP
.RS 4
This macro allows to enable CTS hardware flow control for a given UART instance, without need to call \fBHAL_UART_Init()\fP function\&. As involving direct access to UART registers, usage of this macro should be fully endorsed by user\&. 
.PP
As macro is expected to be used for modifying CTS Hw flow control feature activation, without need for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
.IP "\(bu" 2
UART instance should have already been initialised (through call of \fBHAL_UART_Init()\fP )
.IP "\(bu" 2
macro could only be called when corresponding UART instance is disabled (i\&.e \fBHAL_UART_DISABLE(__HANDLE\fP)) and should be followed by an Enable macro (i\&.e \fBHAL_UART_ENABLE(__HANDLE\fP))\&. 
.PP
.RE
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the UART Handle\&. The Handle Instance can be any USARTx (supporting the HW Flow control feature)\&. It is used to select the USART peripheral (USART availability and x value depending on device)\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_uart\&.h 第 571 行定义\&.
.SS "#define __HAL_UART_HWCONTROL_RTS_DISABLE(__HANDLE__)"
\fB值:\fP
.PP
.nf
  do{                                                      \
    CLEAR_BIT((__HANDLE__)->Instance->CR3, USART_CR3_RTSE);\
    (__HANDLE__)->Init\&.HwFlowCtl &= ~(USART_CR3_RTSE);     \
  } while(0U)
.fi
.PP
Disable RTS flow control This macro allows to disable RTS hardware flow control for a given UART instance, without need to call \fBHAL_UART_Init()\fP function\&. As involving direct access to UART registers, usage of this macro should be fully endorsed by user\&. 
.PP
\fB注解\fP
.RS 4
As macro is expected to be used for modifying RTS Hw flow control feature activation, without need for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
.IP "\(bu" 2
UART instance should have already been initialised (through call of \fBHAL_UART_Init()\fP )
.IP "\(bu" 2
macro could only be called when corresponding UART instance is disabled (i\&.e \fBHAL_UART_DISABLE(__HANDLE\fP)) and should be followed by an Enable macro (i\&.e \fBHAL_UART_ENABLE(__HANDLE\fP))\&. 
.PP
.RE
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the UART Handle\&. The Handle Instance can be any USARTx (supporting the HW Flow control feature)\&. It is used to select the USART peripheral (USART availability and x value depending on device)\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_uart\&.h 第 631 行定义\&.
.SS "#define __HAL_UART_HWCONTROL_RTS_ENABLE(__HANDLE__)"
\fB值:\fP
.PP
.nf
  do{                                                     \
    SET_BIT((__HANDLE__)->Instance->CR3, USART_CR3_RTSE); \
    (__HANDLE__)->Init\&.HwFlowCtl |= USART_CR3_RTSE;       \
  } while(0U)
.fi
.PP
Enable RTS flow control This macro allows to enable RTS hardware flow control for a given UART instance, without need to call \fBHAL_UART_Init()\fP function\&. As involving direct access to UART registers, usage of this macro should be fully endorsed by user\&. 
.PP
\fB注解\fP
.RS 4
As macro is expected to be used for modifying RTS Hw flow control feature activation, without need for USART instance Deinit/Init, following conditions for macro call should be fulfilled :
.IP "\(bu" 2
UART instance should have already been initialised (through call of \fBHAL_UART_Init()\fP )
.IP "\(bu" 2
macro could only be called when corresponding UART instance is disabled (i\&.e \fBHAL_UART_DISABLE(__HANDLE\fP)) and should be followed by an Enable macro (i\&.e \fBHAL_UART_ENABLE(__HANDLE\fP))\&. 
.PP
.RE
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the UART Handle\&. The Handle Instance can be any USARTx (supporting the HW Flow control feature)\&. It is used to select the USART peripheral (USART availability and x value depending on device)\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_uart\&.h 第 611 行定义\&.
.SS "#define __HAL_UART_ONE_BIT_SAMPLE_DISABLE(__HANDLE__)   ((__HANDLE__)\->Instance\->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT))"

.PP
Macro to disable the UART's one bit sample method 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the UART Handle\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_uart\&.h 第 647 行定义\&.
.SS "#define __HAL_UART_ONE_BIT_SAMPLE_ENABLE(__HANDLE__)   ((__HANDLE__)\->Instance\->CR3|= USART_CR3_ONEBIT)"

.PP
Macro to enable the UART's one bit sample method 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the UART Handle\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_uart\&.h 第 641 行定义\&.
.SS "#define __HAL_UART_RESET_HANDLE_STATE(__HANDLE__)"
\fB值:\fP
.PP
.nf
                                                       do{                                                   \
                                                       (__HANDLE__)->gState = HAL_UART_STATE_RESET;      \
                                                       (__HANDLE__)->RxState = HAL_UART_STATE_RESET;     \
                                                     } while(0U)
.fi
.PP
Reset UART handle gstate & RxState 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the UART Handle\&. UART Handle selects the USARTx or UARTy peripheral (USART,UART availability and x,y values depending on device)\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_uart\&.h 第 396 行定义\&.
.SH "作者"
.PP 
由 Doyxgen 通过分析 STM32F4_HAL 的 源代码自动生成\&.
