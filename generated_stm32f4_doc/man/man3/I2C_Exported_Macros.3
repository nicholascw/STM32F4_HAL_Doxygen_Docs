.TH "I2C_Exported_Macros" 3 "2020年 八月 7日 星期五" "Version 1.24.0" "STM32F4_HAL" \" -*- nroff -*-
.ad l
.nh
.SH NAME
I2C_Exported_Macros
.SH SYNOPSIS
.br
.PP
.SS "宏定义"

.in +1c
.ti -1c
.RI "#define \fB__HAL_I2C_RESET_HANDLE_STATE\fP(__HANDLE__)   ((__HANDLE__)\->State = \fBHAL_I2C_STATE_RESET\fP)"
.br
.RI "Reset I2C handle state\&. "
.ti -1c
.RI "#define \fB__HAL_I2C_ENABLE_IT\fP(__HANDLE__,  __INTERRUPT__)   SET_BIT((__HANDLE__)\->Instance\->CR2,(__INTERRUPT__))"
.br
.RI "Enable or disable the specified I2C interrupts\&. "
.ti -1c
.RI "#define \fB__HAL_I2C_DISABLE_IT\fP(__HANDLE__,  __INTERRUPT__)   CLEAR_BIT((__HANDLE__)\->Instance\->CR2, (__INTERRUPT__))"
.br
.ti -1c
.RI "#define \fB__HAL_I2C_GET_IT_SOURCE\fP(__HANDLE__,  __INTERRUPT__)   ((((__HANDLE__)\->Instance\->CR2 & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)"
.br
.RI "Checks if the specified I2C interrupt source is enabled or disabled\&. "
.ti -1c
.RI "#define \fB__HAL_I2C_GET_FLAG\fP(__HANDLE__,  __FLAG__)"
.br
.RI "Checks whether the specified I2C flag is set or not\&. "
.ti -1c
.RI "#define \fB__HAL_I2C_CLEAR_FLAG\fP(__HANDLE__,  __FLAG__)   ((__HANDLE__)\->Instance\->SR1 = ~((__FLAG__) & \fBI2C_FLAG_MASK\fP))"
.br
.RI "Clears the I2C pending flags which are cleared by writing 0 in a specific bit\&. "
.ti -1c
.RI "#define \fB__HAL_I2C_CLEAR_ADDRFLAG\fP(__HANDLE__)"
.br
.RI "Clears the I2C ADDR pending flag\&. "
.ti -1c
.RI "#define \fB__HAL_I2C_CLEAR_STOPFLAG\fP(__HANDLE__)"
.br
.RI "Clears the I2C STOPF pending flag\&. "
.ti -1c
.RI "#define \fB__HAL_I2C_ENABLE\fP(__HANDLE__)   SET_BIT((__HANDLE__)\->Instance\->CR1, I2C_CR1_PE)"
.br
.RI "Enable the specified I2C peripheral\&. "
.ti -1c
.RI "#define \fB__HAL_I2C_DISABLE\fP(__HANDLE__)   CLEAR_BIT((__HANDLE__)\->Instance\->CR1, I2C_CR1_PE)"
.br
.RI "Disable the specified I2C peripheral\&. "
.in -1c
.SH "详细描述"
.PP 

.SH "宏定义说明"
.PP 
.SS "#define __HAL_I2C_CLEAR_ADDRFLAG(__HANDLE__)"
\fB值:\fP
.PP
.nf
  do{                                           \
    __IO uint32_t tmpreg = 0x00U;               \
    tmpreg = (__HANDLE__)->Instance->SR1;       \
    tmpreg = (__HANDLE__)->Instance->SR2;       \
    UNUSED(tmpreg);                             \
  } while(0)
.fi
.PP
Clears the I2C ADDR pending flag\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the I2C Handle\&. This parameter can be I2C where x: 1, 2, or 3 to select the I2C peripheral\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_i2c\&.h 第 493 行定义\&.
.SS "#define __HAL_I2C_CLEAR_FLAG(__HANDLE__, __FLAG__)   ((__HANDLE__)\->Instance\->SR1 = ~((__FLAG__) & \fBI2C_FLAG_MASK\fP))"

.PP
Clears the I2C pending flags which are cleared by writing 0 in a specific bit\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the I2C Handle\&. 
.br
\fI<strong>FLAG</strong>\fP specifies the flag to clear\&. This parameter can be any combination of the following values: 
.PD 0

.IP "\(bu" 2
I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode) 
.IP "\(bu" 2
I2C_FLAG_AF: Acknowledge failure flag 
.IP "\(bu" 2
I2C_FLAG_ARLO: Arbitration lost flag (Master mode) 
.IP "\(bu" 2
I2C_FLAG_BERR: Bus error flag 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_i2c\&.h 第 486 行定义\&.
.SS "#define __HAL_I2C_CLEAR_STOPFLAG(__HANDLE__)"
\fB值:\fP
.PP
.nf
  do{                                                  \
    __IO uint32_t tmpreg = 0x00U;                      \
    tmpreg = (__HANDLE__)->Instance->SR1;              \
    SET_BIT((__HANDLE__)->Instance->CR1, I2C_CR1_PE);  \
    UNUSED(tmpreg);                                    \
  } while(0)
.fi
.PP
Clears the I2C STOPF pending flag\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the I2C Handle\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_i2c\&.h 第 505 行定义\&.
.SS "#define __HAL_I2C_DISABLE(__HANDLE__)   CLEAR_BIT((__HANDLE__)\->Instance\->CR1, I2C_CR1_PE)"

.PP
Disable the specified I2C peripheral\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the I2C Handle\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_i2c\&.h 第 523 行定义\&.
.SS "#define __HAL_I2C_DISABLE_IT(__HANDLE__, __INTERRUPT__)   CLEAR_BIT((__HANDLE__)\->Instance\->CR2, (__INTERRUPT__))"

.PP
在文件 stm32f4xx_hal_i2c\&.h 第 436 行定义\&.
.SS "#define __HAL_I2C_ENABLE(__HANDLE__)   SET_BIT((__HANDLE__)\->Instance\->CR1, I2C_CR1_PE)"

.PP
Enable the specified I2C peripheral\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the I2C Handle\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_i2c\&.h 第 517 行定义\&.
.SS "#define __HAL_I2C_ENABLE_IT(__HANDLE__, __INTERRUPT__)   SET_BIT((__HANDLE__)\->Instance\->CR2,(__INTERRUPT__))"

.PP
Enable or disable the specified I2C interrupts\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the I2C Handle\&. 
.br
\fI<strong>INTERRUPT</strong>\fP specifies the interrupt source to enable or disable\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
I2C_IT_BUF: Buffer interrupt enable 
.IP "\(bu" 2
I2C_IT_EVT: Event interrupt enable 
.IP "\(bu" 2
I2C_IT_ERR: Error interrupt enable 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_i2c\&.h 第 435 行定义\&.
.SS "#define __HAL_I2C_GET_FLAG(__HANDLE__, __FLAG__)"
\fB值:\fP
.PP
.nf
                                                  ((((uint8_t)((__FLAG__) >> 16U)) == 0x01U) ? \
                                                  (((((__HANDLE__)->Instance->SR1) & ((__FLAG__) & I2C_FLAG_MASK)) == ((__FLAG__) & I2C_FLAG_MASK)) ? SET : RESET) : \
                                                  (((((__HANDLE__)->Instance->SR2) & ((__FLAG__) & I2C_FLAG_MASK)) == ((__FLAG__) & I2C_FLAG_MASK)) ? SET : RESET))
.fi
.PP
Checks whether the specified I2C flag is set or not\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the I2C Handle\&. 
.br
\fI<strong>FLAG</strong>\fP specifies the flag to check\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
I2C_FLAG_OVR: Overrun/Underrun flag 
.IP "\(bu" 2
I2C_FLAG_AF: Acknowledge failure flag 
.IP "\(bu" 2
I2C_FLAG_ARLO: Arbitration lost flag 
.IP "\(bu" 2
I2C_FLAG_BERR: Bus error flag 
.IP "\(bu" 2
I2C_FLAG_TXE: Data register empty flag 
.IP "\(bu" 2
I2C_FLAG_RXNE: Data register not empty flag 
.IP "\(bu" 2
I2C_FLAG_STOPF: Stop detection flag 
.IP "\(bu" 2
I2C_FLAG_ADD10: 10-bit header sent flag 
.IP "\(bu" 2
I2C_FLAG_BTF: Byte transfer finished flag 
.IP "\(bu" 2
I2C_FLAG_ADDR: Address sent flag Address matched flag 
.IP "\(bu" 2
I2C_FLAG_SB: Start bit flag 
.IP "\(bu" 2
I2C_FLAG_DUALF: Dual flag 
.IP "\(bu" 2
I2C_FLAG_GENCALL: General call header flag 
.IP "\(bu" 2
I2C_FLAG_TRA: Transmitter/Receiver flag 
.IP "\(bu" 2
I2C_FLAG_BUSY: Bus busy flag 
.IP "\(bu" 2
I2C_FLAG_MSL: Master/Slave flag 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fIThe\fP new state of \fBFLAG\fP (TRUE or FALSE)\&. 
.RE
.PP

.PP
在文件 stm32f4xx_hal_i2c\&.h 第 472 行定义\&.
.SS "#define __HAL_I2C_GET_IT_SOURCE(__HANDLE__, __INTERRUPT__)   ((((__HANDLE__)\->Instance\->CR2 & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)"

.PP
Checks if the specified I2C interrupt source is enabled or disabled\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the I2C Handle\&. 
.br
\fI<strong>INTERRUPT</strong>\fP specifies the I2C interrupt source to check\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
I2C_IT_BUF: Buffer interrupt enable 
.IP "\(bu" 2
I2C_IT_EVT: Event interrupt enable 
.IP "\(bu" 2
I2C_IT_ERR: Error interrupt enable 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fIThe\fP new state of \fBINTERRUPT\fP (TRUE or FALSE)\&. 
.RE
.PP

.PP
在文件 stm32f4xx_hal_i2c\&.h 第 447 行定义\&.
.SS "#define __HAL_I2C_RESET_HANDLE_STATE(__HANDLE__)   ((__HANDLE__)\->State = \fBHAL_I2C_STATE_RESET\fP)"

.PP
Reset I2C handle state\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the I2C Handle\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_i2c\&.h 第 423 行定义\&.
.SH "作者"
.PP 
由 Doyxgen 通过分析 STM32F4_HAL 的 源代码自动生成\&.
