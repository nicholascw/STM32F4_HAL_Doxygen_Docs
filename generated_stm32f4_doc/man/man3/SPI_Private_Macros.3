.TH "SPI_Private_Macros" 3 "2020年 八月 7日 星期五" "Version 1.24.0" "STM32F4_HAL" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SPI_Private_Macros
.SH SYNOPSIS
.br
.PP
.SS "宏定义"

.in +1c
.ti -1c
.RI "#define \fBSPI_1LINE_TX\fP(__HANDLE__)   SET_BIT((__HANDLE__)\->Instance\->CR1, SPI_CR1_BIDIOE)"
.br
.RI "Set the SPI transmit-only mode\&. "
.ti -1c
.RI "#define \fBSPI_1LINE_RX\fP(__HANDLE__)   CLEAR_BIT((__HANDLE__)\->Instance\->CR1, SPI_CR1_BIDIOE)"
.br
.RI "Set the SPI receive-only mode\&. "
.ti -1c
.RI "#define \fBSPI_RESET_CRC\fP(__HANDLE__)"
.br
.RI "Reset the CRC calculation of the SPI\&. "
.ti -1c
.RI "#define \fBSPI_CHECK_FLAG\fP(__SR__,  __FLAG__)   ((((__SR__) & ((__FLAG__) & \fBSPI_FLAG_MASK\fP)) == ((__FLAG__) & \fBSPI_FLAG_MASK\fP)) ? SET : RESET)"
.br
.RI "Check whether the specified SPI flag is set or not\&. "
.ti -1c
.RI "#define \fBSPI_CHECK_IT_SOURCE\fP(__CR2__,  __INTERRUPT__)   ((((__CR2__) & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)"
.br
.RI "Check whether the specified SPI Interrupt is set or not\&. "
.ti -1c
.RI "#define \fBIS_SPI_MODE\fP(__MODE__)"
.br
.RI "Checks if SPI Mode parameter is in allowed range\&. "
.ti -1c
.RI "#define \fBIS_SPI_DIRECTION\fP(__MODE__)"
.br
.RI "Checks if SPI Direction Mode parameter is in allowed range\&. "
.ti -1c
.RI "#define \fBIS_SPI_DIRECTION_2LINES\fP(__MODE__)   ((__MODE__) == \fBSPI_DIRECTION_2LINES\fP)"
.br
.RI "Checks if SPI Direction Mode parameter is 2 lines\&. "
.ti -1c
.RI "#define \fBIS_SPI_DIRECTION_2LINES_OR_1LINE\fP(__MODE__)"
.br
.RI "Checks if SPI Direction Mode parameter is 1 or 2 lines\&. "
.ti -1c
.RI "#define \fBIS_SPI_DATASIZE\fP(__DATASIZE__)"
.br
.RI "Checks if SPI Data Size parameter is in allowed range\&. "
.ti -1c
.RI "#define \fBIS_SPI_CPOL\fP(__CPOL__)"
.br
.RI "Checks if SPI Serial clock steady state parameter is in allowed range\&. "
.ti -1c
.RI "#define \fBIS_SPI_CPHA\fP(__CPHA__)"
.br
.RI "Checks if SPI Clock Phase parameter is in allowed range\&. "
.ti -1c
.RI "#define \fBIS_SPI_NSS\fP(__NSS__)"
.br
.RI "Checks if SPI Slave Select parameter is in allowed range\&. "
.ti -1c
.RI "#define \fBIS_SPI_BAUDRATE_PRESCALER\fP(__PRESCALER__)"
.br
.RI "Checks if SPI Baudrate prescaler parameter is in allowed range\&. "
.ti -1c
.RI "#define \fBIS_SPI_FIRST_BIT\fP(__BIT__)"
.br
.RI "Checks if SPI MSB LSB transmission parameter is in allowed range\&. "
.ti -1c
.RI "#define \fBIS_SPI_TIMODE\fP(__MODE__)"
.br
.RI "Checks if SPI TI mode parameter is in allowed range\&. "
.ti -1c
.RI "#define \fBIS_SPI_CRC_CALCULATION\fP(__CALCULATION__)"
.br
.RI "Checks if SPI CRC calculation enabled state is in allowed range\&. "
.ti -1c
.RI "#define \fBIS_SPI_CRC_POLYNOMIAL\fP(__POLYNOMIAL__)   (((__POLYNOMIAL__) >= 0x1U) && ((__POLYNOMIAL__) <= 0xFFFFU) && (((__POLYNOMIAL__)&0x1U) != 0U))"
.br
.RI "Checks if SPI polynomial value to be used for the CRC calculation, is in allowed range\&. "
.ti -1c
.RI "#define \fBIS_SPI_DMA_HANDLE\fP(__HANDLE__)   ((__HANDLE__) != NULL)"
.br
.RI "Checks if DMA handle is valid\&. "
.in -1c
.SH "详细描述"
.PP 

.SH "宏定义说明"
.PP 
.SS "#define IS_SPI_BAUDRATE_PRESCALER(__PRESCALER__)"
\fB值:\fP
.PP
.nf
                                                  (((__PRESCALER__) == SPI_BAUDRATEPRESCALER_2)   || \
                                                  ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_4)   || \
                                                  ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_8)   || \
                                                  ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_16)  || \
                                                  ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_32)  || \
                                                  ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_64)  || \
                                                  ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_128) || \
                                                  ((__PRESCALER__) == SPI_BAUDRATEPRESCALER_256))
.fi
.PP
Checks if SPI Baudrate prescaler parameter is in allowed range\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>PRESCALER</strong>\fP specifies the SPI Baudrate prescaler\&. This parameter can be a value of \fBSPI BaudRate Prescaler\fP 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_spi\&.h 第 588 行定义\&.
.SS "#define IS_SPI_CPHA(__CPHA__)"
\fB值:\fP
.PP
.nf
                               (((__CPHA__) == SPI_PHASE_1EDGE) || \
                               ((__CPHA__) == SPI_PHASE_2EDGE))
.fi
.PP
Checks if SPI Clock Phase parameter is in allowed range\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>CPHA</strong>\fP specifies the SPI Clock Phase\&. This parameter can be a value of \fBSPI Clock Phase\fP 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_spi\&.h 第 571 行定义\&.
.SS "#define IS_SPI_CPOL(__CPOL__)"
\fB值:\fP
.PP
.nf
                               (((__CPOL__) == SPI_POLARITY_LOW) || \
                               ((__CPOL__) == SPI_POLARITY_HIGH))
.fi
.PP
Checks if SPI Serial clock steady state parameter is in allowed range\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>CPOL</strong>\fP specifies the SPI serial clock steady state\&. This parameter can be a value of \fBSPI Clock Polarity\fP 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_spi\&.h 第 563 行定义\&.
.SS "#define IS_SPI_CRC_CALCULATION(__CALCULATION__)"
\fB值:\fP
.PP
.nf
                                                 (((__CALCULATION__) == SPI_CRCCALCULATION_DISABLE) || \
                                                 ((__CALCULATION__) == SPI_CRCCALCULATION_ENABLE))
.fi
.PP
Checks if SPI CRC calculation enabled state is in allowed range\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>CALCULATION</strong>\fP specifies the SPI CRC calculation enable state\&. This parameter can be a value of \fBSPI CRC Calculation\fP 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_spi\&.h 第 618 行定义\&.
.SS "#define IS_SPI_CRC_POLYNOMIAL(__POLYNOMIAL__)   (((__POLYNOMIAL__) >= 0x1U) && ((__POLYNOMIAL__) <= 0xFFFFU) && (((__POLYNOMIAL__)&0x1U) != 0U))"

.PP
Checks if SPI polynomial value to be used for the CRC calculation, is in allowed range\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>POLYNOMIAL</strong>\fP specifies the SPI polynomial value to be used for the CRC calculation\&. This parameter must be a number between Min_Data = 0 and Max_Data = 65535 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_spi\&.h 第 626 行定义\&.
.SS "#define IS_SPI_DATASIZE(__DATASIZE__)"
\fB值:\fP
.PP
.nf
                                       (((__DATASIZE__) == SPI_DATASIZE_16BIT) || \
                                       ((__DATASIZE__) == SPI_DATASIZE_8BIT))
.fi
.PP
Checks if SPI Data Size parameter is in allowed range\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>DATASIZE</strong>\fP specifies the SPI Data Size\&. This parameter can be a value of \fBSPI Data Size\fP 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_spi\&.h 第 555 行定义\&.
.SS "#define IS_SPI_DIRECTION(__MODE__)"
\fB值:\fP
.PP
.nf
                                    (((__MODE__) == SPI_DIRECTION_2LINES)        || \
                                    ((__MODE__) == SPI_DIRECTION_2LINES_RXONLY) || \
                                    ((__MODE__) == SPI_DIRECTION_1LINE))
.fi
.PP
Checks if SPI Direction Mode parameter is in allowed range\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>MODE</strong>\fP specifies the SPI Direction Mode\&. This parameter can be a value of \fBSPI Direction Mode\fP 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_spi\&.h 第 533 行定义\&.
.SS "#define IS_SPI_DIRECTION_2LINES(__MODE__)   ((__MODE__) == \fBSPI_DIRECTION_2LINES\fP)"

.PP
Checks if SPI Direction Mode parameter is 2 lines\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>MODE</strong>\fP specifies the SPI Direction Mode\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_spi\&.h 第 541 行定义\&.
.SS "#define IS_SPI_DIRECTION_2LINES_OR_1LINE(__MODE__)"
\fB值:\fP
.PP
.nf
                                                    (((__MODE__) == SPI_DIRECTION_2LINES) || \
                                                    ((__MODE__) == SPI_DIRECTION_1LINE))
.fi
.PP
Checks if SPI Direction Mode parameter is 1 or 2 lines\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>MODE</strong>\fP specifies the SPI Direction Mode\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_spi\&.h 第 547 行定义\&.
.SS "#define IS_SPI_DMA_HANDLE(__HANDLE__)   ((__HANDLE__) != NULL)"

.PP
Checks if DMA handle is valid\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies a DMA Handle\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_spi\&.h 第 632 行定义\&.
.SS "#define IS_SPI_FIRST_BIT(__BIT__)"
\fB值:\fP
.PP
.nf
                                   (((__BIT__) == SPI_FIRSTBIT_MSB) || \
                                   ((__BIT__) == SPI_FIRSTBIT_LSB))
.fi
.PP
Checks if SPI MSB LSB transmission parameter is in allowed range\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>BIT</strong>\fP specifies the SPI MSB LSB transmission (whether data transfer starts from MSB or LSB bit)\&. This parameter can be a value of \fBSPI MSB LSB Transmission\fP 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_spi\&.h 第 602 行定义\&.
.SS "#define IS_SPI_MODE(__MODE__)"
\fB值:\fP
.PP
.nf
                               (((__MODE__) == SPI_MODE_SLAVE) || \
                               ((__MODE__) == SPI_MODE_MASTER))
.fi
.PP
Checks if SPI Mode parameter is in allowed range\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>MODE</strong>\fP specifies the SPI Mode\&. This parameter can be a value of \fBSPI Mode\fP 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_spi\&.h 第 525 行定义\&.
.SS "#define IS_SPI_NSS(__NSS__)"
\fB值:\fP
.PP
.nf
                             (((__NSS__) == SPI_NSS_SOFT)       || \
                             ((__NSS__) == SPI_NSS_HARD_INPUT) || \
                             ((__NSS__) == SPI_NSS_HARD_OUTPUT))
.fi
.PP
Checks if SPI Slave Select parameter is in allowed range\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>NSS</strong>\fP specifies the SPI Slave Select management parameter\&. This parameter can be a value of \fBSPI Slave Select Management\fP 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_spi\&.h 第 579 行定义\&.
.SS "#define IS_SPI_TIMODE(__MODE__)"
\fB值:\fP
.PP
.nf
                                 (((__MODE__) == SPI_TIMODE_DISABLE) || \
                                 ((__MODE__) == SPI_TIMODE_ENABLE))
.fi
.PP
Checks if SPI TI mode parameter is in allowed range\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>MODE</strong>\fP specifies the SPI TI mode\&. This parameter can be a value of \fBSPI TI Mode\fP 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_spi\&.h 第 610 行定义\&.
.SS "#define SPI_1LINE_RX(__HANDLE__)   CLEAR_BIT((__HANDLE__)\->Instance\->CR1, SPI_CR1_BIDIOE)"

.PP
Set the SPI receive-only mode\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the SPI Handle\&. This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_spi\&.h 第 484 行定义\&.
.SS "#define SPI_1LINE_TX(__HANDLE__)   SET_BIT((__HANDLE__)\->Instance\->CR1, SPI_CR1_BIDIOE)"

.PP
Set the SPI transmit-only mode\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the SPI Handle\&. This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_spi\&.h 第 477 行定义\&.
.SS "#define SPI_CHECK_FLAG(__SR__, __FLAG__)   ((((__SR__) & ((__FLAG__) & \fBSPI_FLAG_MASK\fP)) == ((__FLAG__) & \fBSPI_FLAG_MASK\fP)) ? SET : RESET)"

.PP
Check whether the specified SPI flag is set or not\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>SR</strong>\fP copy of SPI SR regsiter\&. 
.br
\fI<strong>FLAG</strong>\fP specifies the flag to check\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
SPI_FLAG_RXNE: Receive buffer not empty flag 
.IP "\(bu" 2
SPI_FLAG_TXE: Transmit buffer empty flag 
.IP "\(bu" 2
SPI_FLAG_CRCERR: CRC error flag 
.IP "\(bu" 2
SPI_FLAG_MODF: Mode fault flag 
.IP "\(bu" 2
SPI_FLAG_OVR: Overrun flag 
.IP "\(bu" 2
SPI_FLAG_BSY: Busy flag 
.IP "\(bu" 2
SPI_FLAG_FRE: Frame format error flag 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fISET\fP or RESET\&. 
.RE
.PP

.PP
在文件 stm32f4xx_hal_spi\&.h 第 507 行定义\&.
.SS "#define SPI_CHECK_IT_SOURCE(__CR2__, __INTERRUPT__)   ((((__CR2__) & (__INTERRUPT__)) == (__INTERRUPT__)) ? SET : RESET)"

.PP
Check whether the specified SPI Interrupt is set or not\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>CR2</strong>\fP copy of SPI CR2 regsiter\&. 
.br
\fI<strong>INTERRUPT</strong>\fP specifies the SPI interrupt source to check\&. This parameter can be one of the following values: 
.PD 0

.IP "\(bu" 2
SPI_IT_TXE: Tx buffer empty interrupt enable 
.IP "\(bu" 2
SPI_IT_RXNE: RX buffer not empty interrupt enable 
.IP "\(bu" 2
SPI_IT_ERR: Error interrupt enable 
.PP
.RE
.PP
\fB返回值\fP
.RS 4
\fISET\fP or RESET\&. 
.RE
.PP

.PP
在文件 stm32f4xx_hal_spi\&.h 第 518 行定义\&.
.SS "#define SPI_RESET_CRC(__HANDLE__)"
\fB值:\fP
.PP
.nf
                                       do{CLEAR_BIT((__HANDLE__)->Instance->CR1, SPI_CR1_CRCEN);\
                                       SET_BIT((__HANDLE__)->Instance->CR1, SPI_CR1_CRCEN);}while(0U)
.fi
.PP
Reset the CRC calculation of the SPI\&. 
.PP
\fB参数\fP
.RS 4
\fI<strong>HANDLE</strong>\fP specifies the SPI Handle\&. This parameter can be SPI where x: 1, 2, or 3 to select the SPI peripheral\&. 
.RE
.PP
\fB返回值\fP
.RS 4
\fINone\fP 
.RE
.PP

.PP
在文件 stm32f4xx_hal_spi\&.h 第 491 行定义\&.
.SH "作者"
.PP 
由 Doyxgen 通过分析 STM32F4_HAL 的 源代码自动生成\&.
